#!/bin/bash
# kate: syntax bash
#
# sailfish-patch 2.2.0 (2021-02-28)
# Copyright (C) 2016  Cornerman (https://github.com/cornerman/gen-sailfish-patch)
#               2018-2021  Mirian Margiani
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#

DEPENDENCIES=(
    patch git scp ssh sed xclip
    rpm rpmbuild rpm2cpio cpio tar
    hxselect hxnormalize
    du numfmt html2text
    pngcrush pngquant convert
)

# check environment variables
publish_via_ssh_possible=true
if [[ -z "$SF_PATCH_PASSFILE" ]]; then
    publish_via_ssh_possible=false
fi


if [[ -z "$SF_PATCH_SSH_TARGET" ]]; then
    publish_via_ssh_possible=false
elif [[ "$SF_PATCH_SSH_TARGET" == *@* ]]; then
    tmp_SF_PATCH_REMOTE_USERNAME="${SF_PATCH_SSH_TARGET%%@*}"
    SF_PATCH_SSH_TARGET="${SF_PATCH_SSH_TARGET#*@}"  # remove the user name
fi

if [[ -z "$SF_PATCH_REMOTE_USERNAME" ]]; then
    SF_PATCH_REMOTE_USERNAME="${tmp_SF_PATCH_REMOTE_USERNAME:-nemo}"
elif [[ -n "$tmp_SF_PATCH_REMOTE_USERNAME" ]]; then
    if [[ "$tmp_SF_PATCH_REMOTE_USERNAME" != "$SF_PATCH_REMOTE_USERNAME" ]]; then
        echo "warning: different user names for SSH and deployments are not supported" >/dev/stderr
        echo "         (all commands will use SF_PATCH_REMOTE_USERNAME='$SF_PATCH_REMOTE_USERNAME')"
    fi
fi

if [[ -z "$SF_PATCH_REMOTE_PATH" ]]; then
    SF_PATCH_REMOTE_PATH="/home/$SF_PATCH_REMOTE_USERNAME"
fi

if [[ -z "$SF_PATCH_GLOBAL_DEFAULTS" ]]; then
    SF_PATCH_GLOBAL_DEFAULTS="$HOME/.config/sailfish-patch.conf"
fi

dependencies() { # 1: echo/no-echo
    local ret=0
    local print=
    if [[ "$1" == "echo" ]]; then
        print=true
        echo -e "\nDependencies:"
    fi

    for i in "${DEPENDENCIES[@]}"; do
        if which "$i" 2> /dev/null >&2; then
            if [[ -n "$print" ]]; then
                echo "    - $i: $(which "$i")"
            fi
        else
            if [[ -n "$print" ]]; then
                echo "    - $i: missing"
                ret=1
            else
                return 1
            fi
        fi
    done

    return "$ret"
}

version() {
    echo "\
sailfish-patch 2.2.0 (2021-02-28)
Copyright (C) 2018-2021  Mirian Margiani, 2016  Cornerman
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law."
    dependencies echo
}

if ! dependencies no-echo; then
    version
    echo -e "\nerror: missing dependencies" >/dev/stderr
    exit 255
fi

cSCRIPT="$(basename "$0")"
show_help() {
local script="$cSCRIPT"
    echo "\
** sailfish-patch **

Manage your SailfishOS patches.

Create a new patch skeleton with '-c NAME' and put the original files
in the directory 'original'. Copy everything to the directory 'patched' and
make your changes. Configure the project in 'build/CONFIG'. Build with '-b'.

Note: separate settings pages are currently only supported via Patchmanager.

Usage:
    $script [-b] [-p] [-Po [latest]] [-Pm [latest]] [-S|-S ROUNDS]
    $script -c NAME
    $script -u [DIR]
    $script -i CONFIG SOURCE
    $script [-C|-Cu] FILE
    $script [-h] [-V]

Arguments:
    -c, --create NAME           - create new patch skeleton in NAME
    -C, --check-config FILE     - validate config file FILE
    -Cu, --config-update FILE   - same as -C, but update sections automatically
                                  (e.g. add new releases to the CompatibleVersions section)
    -i, --import CONFIG SOURCE  - setup a new working directory for the given patch
                                  SOURCE can either be a tarball containing the patch file
                                  (unified_diff.patch) in its root, or it can be a patch.
                                  Use -eC to create a new config file.
    -b, --build                 - build RPM and tarball
    -u, --update [DIR]          - update the working directory with the latest sources
                                  This needs a working ssh connection for official source, i.e.
                                  packages not from OpenRepos. Optional DIR to use already
                                  downloaded package files from the given directory.
    -f, --force                 - skip some safety checks
    -p, --publish-ssh           - publish and install patch on your device via ssh
    -Po, --publish-openrepos    - wizard for publishing in OpenRepos
                                  When given 'latest' as argument to -Po, the wizard
                                  will provide info for updating the entry.
    -Pm, --publish-patchmanager - wizard for publishing in PM's online catalogue
                                  See -Po for more details.
    -S, --optimize-screenshots [ROUNDS] - optimize PNG screenshot files of the current project
                                  optional: specify number of processing
                                  rounds for best result (default: 1)

    -V, --version               - show version and license information
    -h, --help                  - show this help and exit

Debug/Development Options:
    -R, --check-releases        - load a list of SailfishOS releases from the Internet
                                  and compare it to the list of versions currently supported
                                  by this script
    -g, --use-git-apply         - use git-apply(1) instead of patch(1) for applying
                                  the patch (see -i and -u)
    -eC, --export-config        - export CONFIG template
    -eL, --export-license       - export COPYING template
    -eG, --export-gitignore     - export .gitignore template
    -eI, --export-icon          - export OpenRepos icon template
    -eJ, --export-json          - export patch.json template
    -eS, --export-spec          - export rpm specfile template

Environment:
    - path to a local file containing your devel-su passphrase
        SF_PATCH_PASSFILE=$SF_PATCH_PASSFILE
    - how to connect to your device via ssh (config name or IP)
        SF_PATCH_SSH_TARGET=$SF_PATCH_SSH_TARGET
    - user name to use for deploying and for ssh connections
        SF_PATCH_REMOTE_USERNAME=$SF_PATCH_REMOTE_USERNAME
    - path to a directory where patch RPMs will be stored on your device
        SF_PATCH_REMOTE_PATH=$SF_PATCH_REMOTE_PATH
    - path to the global configuration file
        SF_PATCH_GLOBAL_DEFAULTS=$SF_PATCH_GLOBAL_DEFAULTS
"
}

check_config=false
check_config_name=
check_update_config=false
create_new=false
create_new_name=
build=false
update=false
update_local_sources=""
import=false
import_config=
import_source=
import_command="$0"
optimize_screenshots=false
optimize_screenshots_runs=1
publish_via_ssh=false
publish_to_openrepos=false
publish_to_pm_catalogue=false
publish_update_only=false
list_releases=false
force=false
patch_utility=patch
debug_export_template=()

while [[ $# > 0 ]]; do
    case "$1" in
        --help|-h) show_help; exit 0;;
        --version|-V) version; exit 0;;
        -C|--check-config)
            check_config=true
            shift

            if [[ -z "$1" ]]; then
                echo "error: no config file name given" >/dev/stderr
                exit 2
            else
                check_config_name="$1"
            fi
        ;;
        -Cu|--config-update)
            check_config=true
            check_update_config=true
            shift

            if [[ -z "$1" ]]; then
                echo "error: no config file name given" >/dev/stderr
                exit 2
            else
                check_config_name="$1"
            fi
        ;;
        -f|--force) force=true;;
        -c|--create)
            create_new=true
            shift

            if [[ -z "$1" ]]; then
                echo "error: no name for the new patch directory given" >/dev/stderr
                exit 1
            else
                create_new_name="$1"
            fi
        ;;
        -b|--build) build=true;;
        -u|--update)
            update=true
            [[ -d "$2" ]] && update_local_sources="$2" && shift
        ;;
        -i|--import)
            import=true
            shift

            if [[ -z "$1" ]]; then
                echo "error: no config file for the import given" >/dev/stderr
                exit 1
            elif [[ ! -f "$1" ]]; then
                echo "error: config file to be imported not found" >/dev/stderr
                exit 1
            else
                # save absolute path
                import_config="$(readlink -m "$(dirname "$1")")/$(basename "$1")"
            fi

            shift
            if [[ -z "$1" ]]; then
                echo "error: no tarball for the import given" >/dev/stderr
                exit 1
            elif [[ ! -f "$1" ]]; then
                echo "error: tarball to be imported not found" >/dev/stderr
                exit 1
            else
                # save absolute path
                import_source="$(readlink -m "$(dirname "$1")")/$(basename "$1")"
            fi
        ;;
        -p|--publish-ssh)
            if [[ "$publish_via_ssh_possible" == false ]]; then
                echo "error: environment not set up correctly for publishing via ssh" >/dev/stderr
                exit 1
            else
                publish_via_ssh=true
            fi
        ;;
        -Po|--publish-openrepos)
            publish_to_openrepos=true
            [[ "$2" == latest ]] && publish_update_only=true && shift
        ;;
        -Pm|--publish-patchmanager)
            publish_to_pm_catalogue=true
            [[ "$2" == latest ]] && publish_update_only=true && shift
        ;;
        -S|--optimize-screenshots)
            optimize_screenshots=true

            if [[ -n "$2" ]] && echo -n "$2" | grep -Pqoe '^\d+$'; then
                optimize_screenshots_runs="$2"
                shift
            fi
        ;;
        -R|--check-releases) list_releases=true;;
        -g|--use-git-apply) patch_utility=git;;
        -eC|--export-config   ) debug_export_template+=(config);;
        -eL|--export-license  ) debug_export_template+=(license);;
        -eG|--export-gitignore) debug_export_template+=(gitignore);;
        -eI|--export-icon     ) debug_export_template+=(icon);;
        -eJ|--export-json     ) debug_export_template+=(json);;
        -eS|--export-spec     ) debug_export_template+=(spec);;
        -*) echo "unknown option: $1";;
        *) shift; continue;;
    esac
    shift
done

check_categories="Homescreen
Browser
Camera
Calendar
Clock
Contacts
Email
Gallery
Media
Messages
Phone
Silica
Settings
Keyboard
Others"

# a list of all Sailfish versions supported by patchmanager
# (taken from: https://coderus.openrepos.net/pm2/upload/)
# note: this list differs from the one at https://coderus.openrepos.net/whitesoft/sailversion
check_versions="1.1.9.30
2.0.2.51
2.0.4.14
2.0.5.6
2.1.0.11
2.1.1.12
2.1.1.23
2.1.1.24
2.1.1.26
2.1.2.3
2.1.3.3
2.1.3.5
2.1.3.7
2.1.4.13
2.1.4.14
2.1.4.15
2.2.0.29
2.2.1.18
2.2.1.19
3.0.0.5
3.0.0.8
3.0.0.11
3.0.1.11
3.0.1.14
3.0.2.8
3.0.3.8
3.0.3.9
3.0.3.10
3.1.0.11
3.2.0.12
3.2.1.20
3.3.0.14
3.3.0.16
3.4.0.22
3.4.0.24
4.0.1.45
4.0.1.48"

declare -A check_default_dummies=(
[SourcePackages]="username:source-package-from-openrepos <= 1.0.10|source-package-from-official-repo"
[Prefix]=""
[DisplayName]="Pretty Name"
[PackageName]="sfos-patch-category-name"
[Category]=""
[Keywords]=""
[Maintainer]="username"
[Summary]="short summary for package managers"
[Description]="long description for the store|possibly spanning over multiple lines"
[DiscussionLink]="https://example.org/discussion"
[DonationsLink]="https://example.org/donations"
[SourcesLink]="https://example.org/sources"
[Version]=""
[Release]=""
[Requires]="another-required-package"
[Conflicts]="my-conflicting-package = 0.0.1|the-old-name"
[Obsoletes]="the-other-old-name"
[Screenshots]=""
[CompatibleVersions]=""
[Changelog]=""
)

declare -A default_config_values=(
[SourcePackages]="m@dummy"
[Prefix]="s@/usr/share"
[DisplayName]="s@dummy"
[PackageName]="s@dummy"
[Category]="s@Others"
[Keywords]="m@Patch"
[Maintainer]="s@dummy"
[Summary]="s@dummy"
[Description]="m@dummy"
[DiscussionLink]="s@dummy"
[DonationsLink]="s@dummy"
[SourcesLink]="s@dummy"
[Version]="s@X.Y.Z"
[Release]="s@N"
[Requires]="m@sailfish-version >= 3.0.0|${check_default_dummies[Requires]}"
[Conflicts]="m@dummy"
[Obsoletes]="m@dummy"
[Screenshots]="m@screenshot-1.png|/home/user/screen-2.png|path/relative/to/config/file/location/screen-3.png"
[CompatibleVersions]="m@$(echo -n "$check_versions" | sort -V | tr '\n' '|' | sed 's/|$//')"
[Changelog]="m@1.0.0 ($(date +%F)):|- initial public release"
)

check_allowed_in_global_config="Prefix
Maintainer
DiscussionLink
DonationsLink
SourcesLink
Release"

trim() {
    local var="$*"
    var="${var#"${var%%[![:space:]]*}"}"
    var="${var%"${var##*[![:space:]]}"}"
    echo -n "$var"
}

select_range() { # 1: from pattern, 2: to pattern
    [[ -z "$1" ]] && return 1 || local from_pattern="$1"
    [[ -z "$2" ]] && return 1 || local to_pattern="$2"
    awk "/$from_pattern/{flag=1;next}/$to_pattern/{flag=0}flag"
}


if [[ "$list_releases" == true ]]; then
    # a list of all Sailfish versions supported by patchmanager
    # (taken from: https://coderus.openrepos.net/pm2/upload/)
    # note: this list differs from the one at https://coderus.openrepos.net/whitesoft/sailversion

    which "curl" 2> /dev/null >&2 && _have_curl=true
    which "column" 2> /dev/null >&2 && _have_column=true

    if [[ "$_have_curl" != true ]]; then
        echo "error: 'curl' is not available, cannot retrieve list of all SailfishOS releases" >/dev/stderr
        error=true
    else
        if ! _all_releases="$(curl -sS https://coderus.openrepos.net/whitesoft/sailversion)"; then
            echo "error: failed to load the list of all releases from https://coderus.openrepos.net/whitesoft/sailversion" >/dev/stderr
            error=true
        else
            _head_line="Script?;Version;Codename;Date"
             _sep_line="-------;-------;--------;----"

            if [[ "$_have_column" == true ]]; then
                # print formatted
                join -t';' -a 1 -a 2 -j 1 -o 1.2,2.1,2.2,2.3 \
                    <(echo "$check_versions" | sed 's/$/;  yes/g' | sort) <(echo "$_all_releases" | sed 's/ - /;/g' | sort) |\
                        sed "1 s/^/$_head_line\n$_sep_line\n/; $ s/$/\n$_sep_line\n$_head_line/" |\
                        sed 's/^;/ ;/g' | column -s ';' -t
            else
                # print unformatted
                echo "note: install 'column' to get formatted output" >/dev/stderr
                join -t',' -a 1 -a 2 -j 1 -o 1.2,2.1,2.2,2.3 \
                    <(echo "$check_versions" | sed 's/$/,yes/g' | sort) <(cho "$_all_releases" | sed 's/ - /,/g' | sort)  |\
                        sed "1 s/^/$_head_line\n/;"
            fi

            echo "
This script only supports SailfishOS releases supported by Patchmanager.
If a version is not marked with 'yes' in the listing above, make sure it is
supported by cross-checking https://coderus.openrepos.net/pm2/upload/. Then
add it to the list of supported versions by updating variable '\$check_versions'
and create a pull request at https://github.com/ichthyosaurus/sailfish-patch."
        fi
    fi

    if [[ "$error" == true ]]; then
        echo -e "\nReleases supported by this script:"
        echo      "----------------------------------"
        echo "$check_versions"
        exit 1
    fi

    exit 0
fi


if [[ "$check_config" == true ]]; then
    if [[ ! -f "$check_config_name" ]]; then
        echo "error: could not find configuration file" >/dev/stderr
        exit 2
    fi

    # check keys and references, files, screenshots
    __check_dummy_value() { # 1: key, 2: value to check, 3: line
        local key="$1"
        local value="$2"
        local line="$3"

        if [[ -z "$value" ]]; then
            return 0
        fi

        if echo "$value" | grep -Pqoe "@[^ ]+@"; then
            echo "error: field '$key' is not configured ($value; line $line)" >/dev/stderr
            return 1
        fi

        if [[ -z "${check_default_dummies[$key]}" ]]; then
            return 0
        elif echo "${check_default_dummies[$key]}" | sed 's/|/\n/g' |\
                grep -Pqoe "^$(echo "$value" | sed 's/[][\.|$(){}?+*^]/\\&/g')"; then
            echo "error: field '$key' still contains a dummy value (line $line)" >/dev/stderr
            return 1
        else
            return 0
        fi
    }

    error=false
    count=0
    keys_found=()

    is_multiline=
    is_multiline_at=0
    is_multiline_required=false
    lines_for_multi=0

    while IFS='' read -r line || [[ -n "$line" ]]; do
        count="$((count+1))"
        line="$(trim "$line")"
        key="${line%%:*}"
        value="$(trim "${line#$key:}")"

        if [[ -z "$line" ]]; then
            continue
        elif [[ "$line" == "#"* ]]; then
            continue
        fi

        if [[ -n "$is_multiline" ]] && [[ "$line" == "-"* ]]; then
            lines_for_multi="$((lines_for_multi+1))"
            value="$(trim "${value#-}")"

            # BEGIN value checks for multi line fields
            __check_package_specification() { # 1: error name
                if ! echo "$value" | grep -Pqe "^([^: ]+:|)[^: ]+( (<|>|=|<=|>=) .+|)$"; then
                    echo "error: invalid $is_multiline package specification '$value' (line $count)" >/dev/stderr
                    error=true # global
                fi
            }

            if [[ "$is_multiline" == "Screenshots" ]]; then
                if [[ ! -f "$value" ]] && [[ ! -f "$(dirname "$check_config_name")/$value" ]]; then
                    echo "error: screenshot file '$value' not found (line $count)" >/dev/stderr
                    error=true
                else
                    screen="$value"
                    if [[ ! -f "$value" ]]; then
                        screen="$(dirname "$check_config_name")/$value"
                    fi

                    if (( "$(du -bs "$screen" | grep -Poe '^\d+')" >= 500000 )); then
                        echo "note: screenshot file '$value' is quite large; did you optimize all PNGs using '-S'?" >/dev/stderr
                    fi
                fi
            elif [[ "$is_multiline" == "CompatibleVersions" ]]; then
                if ! echo "$check_versions" | grep -Pqoe "^$value"; then
                    echo "error: invalid version '$value' (line $count)" >/dev/stderr
                    error=true
                fi
            elif [[    "$is_multiline" == "SourcePackages"
                    || "$is_multiline" == "Requires"
                    || "$is_multiline" == "Obsoletes"
                    || "$is_multiline" == "Conflicts"
            ]]; then
                __check_package_specification
            fi
            # END value checks for multi line fields

            if ! __check_dummy_value "$is_multiline" "$value" "$count"; then
                error=true
            fi

            continue
        fi

        if [[ "$line" != *":"* ]]; then
            echo "warning: comment lines should start with '#' (line $count)"
            continue
        fi

        if [[ -n "$is_multiline" ]]; then
            if (( lines_for_multi == 0 )); then
                echo "warning: empty multi-line field '$is_multiline' at line $is_multiline_at"

                if [[ "$is_multiline_required" == true ]]; then
                    echo "error: required field '$key' is empty" >/dev/stderr
                    error=true
                fi
            fi

            is_multiline=
            is_multiline_at=0
            lines_for_multi=0
            is_multiline_required=false
        fi

        # BEGIN value checks for single line fields
        # single line
        is_single=true
        case "$key" in
            Prefix|DiscussionLink|DonationsLink|SourcesLink)
                # may be empty
                if [[ -z "$value" ]]; then
                    echo "note: no value given for '$key'"
                else
                    # special rules
                    if [[ "$key" == "Prefix" ]]; then
                        if [[ "$value" != "/"* ]]; then
                            echo "error: prefix must be an absolute path ($value; line $count)" >/dev/stderr
                            error=true
                        fi
                    fi
                fi
            ;;
            DisplayName|Maintainer|Summary)
                # must not be empty
                if [[ -z "$value" ]]; then
                    echo "error: required field '$key' is empty" >/dev/stderr
                    error=true
                fi
            ;;
            PackageName)
                # must not be empty
                if [[ -z "$value" ]]; then
                    echo "error: required field '$key' is empty" >/dev/stderr
                    error=true
                fi
                # needs special rules
                if echo "$value" | grep -Pqoe "[^a-zA-Z0-9-_]"; then
                    echo "error: package name contains invalid characters (line $count)" >/dev/stderr
                    echo "       allowed are: a-z, A-Z, 0-9, -, _ (no spaces)"
                    error=true
                elif echo "$value" | grep -Pqoe "^[-_]"; then
                    echo "error: package name must not start with '-' or '_' (line $count)" >/dev/stderr
                    error=true
                elif [[ "$value" == "${check_default_dummies[$key]}" ]]; then
                    echo "error: package name not set (line $count)" >/dev/stderr
                    error=true
                fi
            ;;
            Category)
                # must not be empty
                if [[ -z "$value" ]]; then
                    echo "error: required field '$key' is empty" >/dev/stderr
                    error=true
                fi
                # needs special rules
                if ! echo "$check_categories" | grep -Pqoe "^$value"; then
                    echo "error: invalid category '$value' on line $count" >/dev/stderr
                    error=true
                fi
            ;;
            Version)
                # must not be empty
                if [[ -z "$value" ]]; then
                    echo "error: required field '$key' is empty" >/dev/stderr
                    error=true
                fi
                # needs special rules
                if ! echo "$value" | grep -Pqoe '^[0-9]+\.[0-9]+\.[0-9]+'; then
                    echo "error: version number must consist of three numbers separated by dots (X.Y.Z; line $count)" >/dev/stderr
                    error=true
                fi
            ;;
            Release)
                # must not be empty
                if [[ -z "$value" ]]; then
                    echo "error: required field '$key' is empty" >/dev/stderr
                    error=true
                fi
                # needs special rules
                if ! echo "$value" | grep -Pqoe '^[1-9][0-9]*'; then
                    echo "error: release number must be exactly one number without leading zeros (XYZ; line $count)" >/dev/stderr
                    error=true
                fi
            ;;
            *) is_single=false;;
        esac
        # END value checks for single line fields

        # multi line
        if [[ "$is_single" == false ]]; then
            case "$key" in
                SourcePackages|Screenshots|Changelog|Requires|Keywords|Conflicts|Obsoletes)
                    # regular fields
                    is_multiline="$key"
                    is_multiline_at="$count"
                ;;
                Description|CompatibleVersions)
                    # required fields
                    is_multiline="$key"
                    is_multiline_at="$count"
                    is_multiline_required=true
                ;;
                *)  echo "error: invalid key '$key' on line $count" >/dev/stderr
                    error=true
                ;;
            esac
        fi

        if ! __check_dummy_value "$key" "$value" "$count"; then
            error=true
        fi

        if printf "%s\n" "${keys_found[@]}" | grep -Pqoe "^$key"; then
            echo "error: field '$key' is defined more than once (line $count)" >/dev/stderr
            error=true
        else
            keys_found+=("$key")
        fi
    done < "$check_config_name"

    # check for required fields
    for r in DisplayName PackageName Category Maintainer Summary Version Release Description CompatibleVersions; do
        if ! printf "%s\n" "${keys_found[@]}"  | grep -Pqoe "^$r"; then
            echo "error: required field '$r' is missing" >/dev/stderr
            error=true
        fi
    done

    # check versions
    to_check_list="$(sed '/^\#/d;/^$/d;s/^\s*//g;' "$check_config_name" | # remove comments, blank lines, and leading whitespace
        select_range "CompatibleVersions:" "^[^-]" | # extract the list between CompatibleVersions and the next section
        sed 's/^-\s*//g' | # remove leading '-'
        sort -V)" # sort by version
    to_check_latest="$(echo "$to_check_list" | tail -1)"
    to_check_latest_major="${to_check_latest%%.*}"
    upstream_latest_major="$(echo "$check_versions" | grep -Ee "^[0-9]+\." | sort -u | tail -1 | cut -d. -f1)"
    upstream_more_recent="$(echo "$check_versions" | sort -V |
        select_range "^${to_check_latest//./\.}" "^[^$to_check_latest_major]")"

    if [[ "$upstream_latest_major" != "$to_check_latest_major" ]]; then
        echo "note: this patch does not support the latest SailfishOS version (v$to_check_latest_major vs v$upstream_latest_major)" >/dev/stderr
    fi

    if [[ -n "$upstream_more_recent" ]]; then
        echo "note: there are newer releases for this major SailfishOS version available" >/dev/stderr
        echo -n "$upstream_more_recent" | sed 's/^/- /g' | tee /dev/stderr | xclip -selection c && echo >/dev/stderr

        if [[ "$check_update_config" == true ]]; then
            # update CompatibleVersions
            latest_version_line="$(sed 's/^\s*//g' "$check_config_name" | # remove leading whitespace
                awk '/^CompatibleVersions:$/{flag=1;next}/^[^-# ]/{flag=0} { if (flag && $0 != "") print NR; }' | # print lines in 'CompatibleVersions:'
                tail -1)" # get the last line number
            update_config_name="$(mktemp)"
            cp "$check_config_name" "$update_config_name"
            update_to_add="$(echo -n "$upstream_more_recent" | sed 's/^/- /g;s/$/\\n/g' | tr -d $'\n')"
            sed -i "$latest_version_line s/$/\n$update_to_add/;" "$update_config_name"
            mv "$update_config_name" "$check_config_name" --backup=t
            echo "note: the CompatibleVersions section has been updated"
            echo "note: please check if the patch really is compatible with the new releases"

            # update version and changelog for new releases
            check_update_version=true  # NOTE it might be useful to make this optional
            if [[ "$check_update_version" == true ]]; then
                current_version="$(grep "^Version: " "$check_config_name" | head -1 | cut -d' ' -f2)"
                next_version="$(echo "$current_version" | cut -d. -f1-2).$(echo "$current_version+1" | cut -d. -f3 | bc)"
                sed -i "s/^Version: .*$/Version: $next_version/" "$check_config_name"

                last_compatible="$(echo -n "$upstream_more_recent" | tail -1)"
                sed -i "s/^Changelog:$/Changelog:\n\
- $next_version:\n\
- - update compatibility info: the patch is compatible with all versions of SailfishOS up to $last_compatible\n\
-/"\
                    "$check_config_name"
            fi
        else
            echo "note: if the patch is compatible, consider updating the CompatibleVersions section" >/dev/stderr
        fi
    fi

    if [[ "$error" == true ]]; then
        exit 1
    else
        exit 0
    fi
fi


__save_template_config() { # 1: output file
    cat <<EOF > "$1"
#
# SailfishOS Patch Configuration File
# for sailfish-patch
#
# Fields:
# - one line: Prefix, DisplayName, PackageName, Category,
#             Maintainer, Summary, DiscussionLink, DonationsLink,
#             SourcesLink, Version, Release
# - multiple lines: Keywords, Description, Screenshots,
#             CompatibleVersions, Changelog, Requires,
#             Obsoletes, Conflicts
#   (each line in a multiline field must start with '- ')
#

SourcePackages:
$(__get_default_config "SourcePackages")

Prefix: $(__get_default_config "Prefix")
DisplayName: $(__get_default_config "DisplayName")
PackageName: $(__get_default_config "PackageName")
Category: $(__get_default_config "Category")
# Category must be one of:
#     Homescreen
#     Browser
#     Camera
#     Calendar
#     Clock
#     Contacts
#     Email
#     Gallery
#     Media
#     Messages
#     Phone
#     Silica
#     Settings
#     Keyboard
#     Others
Keywords:
$(__get_default_config "Keywords")

Maintainer: $(__get_default_config "Maintainer")
Summary: $(__get_default_config "Summary")
Description:
$(__get_default_config "Description")

DiscussionLink: $(__get_default_config "DiscussionLink")
DonationsLink: $(__get_default_config "DonationsLink")
SourcesLink: $(__get_default_config "SourcesLink")

Version: $(__get_default_config "Version")
Release: $(__get_default_config "Release")

Requires:
$(__get_default_config "Requires")

Conflicts:
$(__get_default_config "Conflicts")

Obsoletes:
$(__get_default_config "Obsoletes")

Screenshots:
$(__get_default_config "Screenshots")

CompatibleVersions:
$(__get_default_config "CompatibleVersions")

Changelog:
$(__get_default_config "Changelog")

# kate: syntax SailfishOS Patch
EOF
}

__save_template_gitignore() { # 1: output file
    cat <<EOF > "$1"
documentation.list
RPMS
.directory
source-packages
original.tmp
diff_original_*.patch
diff_updated_*.patch
diff_apply_command.sh
diff_applying.patch
original-old-*
patched-old-*
source-packages-old-*
build.*
*~
EOF
}

__save_template_json() { # 1: output file
    cat <<EOF > "$1"
{
    "name": "@DISPLAYNAME@",
    "description": "@DESCRIPTION@",
    "category": "@CATEGORY@",
    "infos": {
        "maintainer": "@MAINTAINER@",
        "discussion": "@DISCUSSIONLINK@",
        "donations": "@DONATIONSLINK@",
        "sources": "@SOURCESLINK@"
    }
}
EOF
}

__save_template_spec() { # 1: output file
    cat <<EOF > "$1"
Name: @PACKAGENAME@
BuildArch: noarch
Summary: @SUMMARY@
Version: @VERSION@
Release: @RELEASE@
Group: System/Patches
License: GPLv3
Packager: @MAINTAINER@
Source0: %{name}-%{version}.tar.xz
Obsoletes: %{name} <= %{version}
Provides: %{name} = %{version}
Requires: patchmanager
@REQUIRES@
@OBSOLETES@
@CONFLICTS@

%define _source_payload w9.gzdio
%define _binary_payload w9.gzdio

%description
%{summary}

%prep
%setup -q -n %{name}-%{version}

%build

%install
rm -rf %{buildroot}

mkdir -p %{buildroot}/usr/share/patchmanager/patches/%{name}
cp -r rpm_build/* %{buildroot}/usr/share/patchmanager/patches/%{name}

%pre
if [ -d /var/lib/patchmanager/ausmt/patches/%{name} ]; then
/usr/sbin/patchmanager -u %{name} || true
fi

%preun
if [ -d /var/lib/patchmanager/ausmt/patches/%{name} ]; then
/usr/sbin/patchmanager -u %{name} || true
fi

%files
%defattr(-,root,root,-)
%{_datadir}/patchmanager/patches/%{name}
EOF
}

__save_template_icon() { # 1: output file
    # original optimized patchmanager icon png, encoded with 'base64 icon.png'
    cat <<EOF | base64 -d > "$1"
iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAMAAACahl6sAAAAGXRFWHRTb2Z0d2FyZQB3d3cuaW5r
c2NhcGUub3Jnm+48GgAAAAlwSFlzAAAgJAAAICQBcEDPXgAAAwBQTFRFR3BMpbCrwMW7y8zCvr++
b5GJn6+meJaOvMC6kqefg52VfJmRzMzCdZWNu8G3xMe9n62nb29vnK2kdnh3obGorLatx8m/lKif
sLqxn62nvL68tLu0kpOTgIeEorGonq6lmaihiqCZoaOil6aguLq5q7etmpyborCoj6Sci4yMq66s
ycrAjZqVlqmhkZqWjqScrbWwsbmxsbizkKadiqKZi6GZsrqxqrSsh4+Lhp+XeXp6mKuijqScgYGB
s7qyhZ2Vg5aQnK2khoeGjJSQu8G4nq6luKOAiKGYs7uzu8G5paqkb3VziI2Lp5hffIiDg5ONtr20
5axu7Ld33qJnhJ6Ws7yztL2zkKadsruyhp+Xlamgtb20sbuxiqKZqratl6qhn6+mnK2kmKuig52V
jKObrbivuL+2wsW8rLiugZyUvsO6rLeueZePucC2na6lwMS7iKGYoLCnw8a9mqyju8G4jaSbf5uT
iaGZvMK4qLWsfpqShZ+WsLqxi6Oat761xMe9fZqRpbOqfJmRprSrgp2UdpWNpLOpj6Wco7KporGo
epiQkaaekqeedJSMh6CYvcK5/PTrp7SrlKifh6CXyMm/d5aOtr61e5iQr7qwr7mwrrmvrrmwt7+1
zMzCjqWcjqScxci+ycrAgJyTc5OLcZKKusC3usG3gJuTqbasxsi+bpCIk6efcJGJk6ify8vBobGo
iKCYiaGY5Kttd5aN46lsj6Wd4adqp7Wrm6yjlKignK6lobCn3aFn4KRpKNpO2p9l26Np/QEA1pxj
6LBxzZhh7bt94K1z0ppi6rN0ypJd16BmwrWY++/h0rSI8ciXvKyMyrSPs7Wk37Z/rK2Y78CHtKyS
1aNuyqyCvLeg1LB/996/v6V/w66Kt7CWoKKN0aV0rKOHtp9da7pU+ejTx6R42a1457d6lqSVmqRY
WcFSpK2fqrKlnqmaRctQ+OTL1HlN7hkP11c3kKxZLddOONFP89Go9Nay4TQhoZZVebNVwZNcraqR
mKtptY1XtamMiKlV/zDAIwAAAFF0Uk5TALzZ2JvICBC1FcnIkMjYkNXvLOlU9ddEj8amysDmOh3n
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
DDsAAAAASUVORK5CYII=
EOF
}

__save_template_copying() { # 1: output file
    # GPL v3 compressed via 'cat COPYING | xz | base64'
    cat <<EOF | base64 -d | xz -d > "$1"
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
EOF
}

get_single_config() { # 1: config file, 2: key, 3: default value
    # we can safely assume the file exists and is valid
    # which means we can also assume the key exists if it is required

    local line="$(grep "^$2:" "$1" | head -1)"

    if [[ -z "$line" ]]; then
        echo "$3"
        return
    fi

    local key="${line%%:*}"
    local value="$(trim "${line#$key:}")"

    if [[ -z "$value" ]]; then
        echo -n "$3"
    else
        echo -n "$value"
    fi
}

get_multi_config() { # 1: config file, 2: key, 3: default value
    # we can safely assume the file exists and is valid
    # which means we can also assume the key exists if it is required

    local key_at="$(grep -nr "^$2:" "$1" | cut -d':' -f1)"
    local lines=()
    readarray -t lines <<<"$(tail --lines=+"$((key_at+1))" "$1")"
    local selected=()

    for l in "${lines[@]}"; do
        local first="${l:0:1}"

        case "$first" in
            -) selected+=("$(trim "${l:1}")");;
            "#") echo -n;;  # ignore comments
            *)  if [[ "$l" == *":"* ]]; then
                    break # is next key; done
                else
                    echo -n # ignore as comment
                fi
            ;;
        esac
    done

    if (( ${#selected[@]} == 0 )); then
        echo -n "$3"
    else
        printf "%s\n" "${selected[@]}"
    fi
}

config_checker="$0"
require_config() { # 1: expected config file location
    local config="$1"
    if [[ ! -f "$config" ]]; then
        echo "error: could not find config file" >/dev/stderr
        return 1
    else
        "$config_checker" --check-config "$config"

        if (( $? != 0 )); then
            echo "error: config file contains errors" >/dev/stderr
            echo "       please check the output above and try again" >/dev/stderr
            return 1
        fi
    fi

    return 0
}

# NOTE place above __save_template_config?
require_global_config() {
    if [[ -z "$SF_PATCH_GLOBAL_DEFAULTS" ]]; then
        echo "internal error: \$SF_PATCH_GLOBAL_DEFAULTS is empty" >/dev/stderr
        return 1
    fi

    mkdir -p "$(dirname "$SF_PATCH_GLOBAL_DEFAULTS")"

    if [[ ! -f "$SF_PATCH_GLOBAL_DEFAULTS" ]]; then
        cat <<EOF > "$SF_PATCH_GLOBAL_DEFAULTS"
# Default configuration values for sailfish-patch
#
# The values configured here will be used as default values in new
# CONFIG files generated by sailfish-patch. They have no effect for already
# existing files.
#
# Only the following (single-line) fields can be configured here:
$(echo -n "$check_allowed_in_global_config" | tr '\n' ' ' | sed 's/^/# /g;s/ $//;')
#
# Lines starting with '#' will be ignored.
# Entry lines are key-value pairs joined by ':' (one entry per line).

# Release: 1
# Prefix: /usr/share
# Maintainer: Foo Bar
# DiscussionLink: https://discuss.example.org/foobar
# DonationsLink: https://donate.example.org/foobar
# SourcesLink: https://sources.example.org/foobar

# [keep this line: sailfish-patch 2.2.0 (2021-02-28)]
# kate: syntax SailfishOS Patch
EOF
    fi
}

# return the default configuration value for field $1
# The function takes globally configured defaults into account and returns,
# if available, the global value or else the dummy value.
# NOTE place above __save_template_config?
__get_default_config() { # 1: field/key
    require_global_config || exit 1
    [[ -z "$1" ]] && return 1

    if echo -n "$check_allowed_in_global_config" | grep -Pqoe "^$1$" && grep -Pqoe "^$1:" "$SF_PATCH_GLOBAL_DEFAULTS"; then
        value="$(grep -Pe "^$1:" "$SF_PATCH_GLOBAL_DEFAULTS" | cut -d\: -f2-)"
        value="$(trim "$value")"
        echo "$value"
    elif [[ -n "${default_config_values[$1]}" ]]; then
        value="${default_config_values[$1]}"
        type="${value%%@*}"

        if [[ "$value" == [ms]"@dummy" ]]; then
            value="${check_default_dummies[$1]}"
        else
            value="${value#*@}"
        fi

        if [[ "$type" == m ]]; then
            echo "$value" | sed 's/^/- /;s/|/\n- /g'
        else
            echo "$value"
        fi
    else
        echo "error: default value for invalid key requested ($1)" >/dev/stderr
        return 1
    fi
}

# return unchecked base config path to be used
# in validator functions
__get_config_path() {
    if [[ -f "$(pwd)/build/CONFIG" ]]; then
        echo "warning: config file in non-standard location found (below 'build')" >/dev/stderr
    fi

    echo -n "$(pwd)/CONFIG"
}

# return unchecked base build path to be used in
# validator functions
__get_build_path() {
    echo -n "$(pwd)/build"
}

# return path of latest package build
# assumes build path and config have been checked before
__get_package_path() { # 1: type (rpm/tarball)
    if [[ "$1" != "rpm" && "$1" != "tarball" ]]; then
        echo "internal error: invalid package type requested" >/dev/stderr
        return 1
    fi

    local extension=""
    if [[ "$1" == rpm ]]; then
        extension="noarch.rpm"
    else
        extension="tar.gz"
    fi

    local config="$(__get_config_path)"
    local package_name="$(get_single_config "$config" "PackageName")"
    local version="$(get_single_config "$config" "Version")"
    local release="$(get_single_config "$config" "Release")"
    local package="$(find "$(__get_build_path)" -maxdepth 1 -iname "$package_name-$version-$release.$extension" | sort --version-sort | tail -1)"

    echo -n "$package"
}

# return default original files path
__get_original_path() {
    echo -n "$(pwd)/original"
}

# return default patched files path
__get_patched_path() {
    echo -n "$(pwd)/patched"
}

# return default source package path
__get_sources_path() {
    echo -n "$(pwd)/source-packages"
}

# return default extras path
__get_extra_path() {
    echo -n "$(pwd)/extra"
}

require_build_config() {
    # require valid config
    local config="$(__get_config_path)"
    require_config "$config" || return 1

    # require build dir
    local build_dir="$(__get_build_path)"
    if [[ ! -d "$build_dir" ]]; then
        echo "note: creating new build directory" >/dev/stderr
        mkdir -p "$build_dir" || {
            echo "error: failed to create new build directory" >/dev/stderr
            return 1
        }
    fi

    return 0
}

require_current_package() { # 1: type (rpm/tarball)
    require_build_config || return 1
    local config="$(__get_config_path)"
    local build_dir="$(__get_build_path)"

    # find package file
    local package="$(__get_package_path "$1")"

    if [[ -z "$package" ]]; then
        echo "error: no $1 found" >/dev/stderr
        return 1
    fi

    return 0
}

# create diff and save it to $2
# assumes config is valid
__create_diff() { # 1: config, 2: save path
    local prefix="$(get_single_config "$1" "Prefix" "/")"

    if [[ "$prefix" != "/" && "$prefix" != *"/" ]]; then
        prefix="$prefix/"
    fi

    local original="$(__get_original_path)"
    local patched="$(__get_patched_path)"

    git -c core.quotepath=off diff --no-index --src-prefix="a${prefix}" --dst-prefix="b${prefix}" -- "$original" "$patched" |\
        sed -Ee "s@(--git|---|\+\+\+) (\"?)(a|b)${prefix}(${original#/}|${patched#/})/@\1 \2\3${prefix}@g;
                    s@(--git a/.*) (\"?)b${prefix}${patched#/}/@\1 \2b${prefix}@g;
                        s@(---|\+\+\+) (.*?)\t@\1 \2@g;" > "$2"
}

__print_initial_help() { # 1: original path, 2: patched path, 3: extra path
    local title="Short How-To"
    local original="$(basename "$1")"
    local patched="$(basename "$2")"
    local extra="$(basename "$3")"

    [[ -n "$create_new_name" ]] && title="$create_new_name -- $title"

    cat <<EOF
== SailfishOS Patch: $title ==

1. configure the patch by editing 'CONFIG'
    - add all source packages to the 'SourcePackages' field
    - update basic info about the patch
    - run '$cSCRIPT -C CONFIG' to check for configuration mistakes
2. bootstrap sources by running '$cSCRIPT -u'
    - note: it must be possible for '$cSCRIPT' to connect to your device via
      SSH if you want to use source packages from the official repos. Make sure
      this is configured correctly. This is not needed for OpenRepos sources.
    - alternatively, put original sources in '$original' and copy them to '$patched'
3. commit clean sources
4. make any changes in '$patched'

5. optionally: add extra files like translations, icons, or settings to the
   '$extra' directory
    - allowed file extensions: .qml, .js, .png, .svg, .qm
    - translations files must be named 'translation_LANG.qm'
    - patch icon must be named 'main.png' ('main-light.png') or 'main.svg' ('main-light.svg')
    - patch settings page must be named 'main.qml'
    - no sub-directories are allowed
    - see https://coderus.openrepos.net/pm2/usage/ for further details

For updating the patch to new upstream versions, simply run '$cSCRIPT -u'.

Tips:
- Use 'rpm -qf /path/to/file' to find out which package a file belongs to.
- Use 'pkcon get-details packagename' to check which version is installed.
- Use '$cSCRIPT -b -p' to test the patch directly after building (needs SSH).
- Do not push your patch to a public repository. Instead, publish the 'code
  distribution package' which includes only the files that belong to you.
  Other users can rebuild the development environment by running
  '$cSCRIPT -u' in the published directory. This way, you do not have to
  publish potentially copyrighted material without permission.
EOF
}


if [[ "$create_new" == true ]]; then
    if [[ -e "$create_new_name" ]]; then
        echo "error: a file or directory with the name '$create_new_name' already exists" >/dev/stderr
        exit 1
    fi

    mkdir -p "$create_new_name"
    cd "$create_new_name"

    git init
    git checkout -b master

    mkdir -p "$(__get_extra_path)"
    mkdir -p "$(__get_original_path)"
    mkdir -p "$(__get_patched_path)"
    mkdir -p "$(__get_sources_path)"
    mkdir -p "$(__get_build_path)"

    __save_template_config CONFIG
    __save_template_copying COPYING
    __save_template_gitignore .gitignore

    git add CONFIG COPYING .gitignore
    git commit -m "patch skeleton automatically created by sailfish-patch"

    echo "patch created: $create_new_name"

    __print_initial_help "$(__get_original_path)" "$(__get_patched_path)" "$(__get_extra_path)"

    exit 0
else
    __update_is_valid_version() { # 1: comparison (>, <, >=, <=, =); 2,3: versions to compare
        local comparison="$1"
        local check_1="${2%%-*}" # strip release
        local check_2="${3%%-*}"

        get_largest() {
            printf '%s\n' "$@" | sort --version-sort | head -1
        }

        get_smallest() {
            printf '%s\n' "$@" | sort --version-sort | tail -1
        }

        ok=false
        case "$comparison" in
            ">") if [[ "$(get_largest "$check_1" "$check_2")" != "$check_1" ]]; then
                    ok=true
                fi
            ;;
            ">=") if [[ "$check_1" == "$check_2" || "$(get_largest "$check_1" "$check_2")" != "$check_1" ]]; then
                    ok=true
                fi
            ;;
            "<") if [[ "$(get_smallest "$check_1" "$check_2")" != "$check_1" ]]; then
                    ok=true
                fi
            ;;
            "<=") if [[ "$check_1" == "$check_2" || "$(get_smallest "$check_1" "$check_2")" != "$check_1" ]]; then
                    ok=true
                fi
            ;;
            "=") if [[ "$check_1" == "$check_2" ]]; then
                    ok=true
                fi
            ;;
        esac

        if [[ "$ok" == false ]]; then
            return 1
        else
            return 0
        fi
    }

    # we assume config has been checked before and is valid
    __update_fetch_latest_sources() { # 1: optionally a suffix for source backups
        local original="$(__get_original_path)"
        local config="$(__get_config_path)"
        local packages="$(__get_sources_path)"
        local extract="${packages%/}/extract"
        local base="$(pwd)"
        local -r openrepos_url="https://sailfish.openrepos.net/"
        local packages_backup=''
        [[ -n "$1" ]] && packages_backup="$packages-old-$1"

        if ! rm -rf "$original"; then
            echo "error: failed to remove old original sources" >/dev/stderr
            return 1
        fi

        if [[ -d "$packages" ]]; then
            if [[ -n "$packages_backup" ]]; then
                mv --backup=t -T "$packages" "$packages_backup"
            else
                rm -rf "$packages" || return 1
            fi
        fi

        if [[ -d "$extract" ]]; then
            rm -rf "$extract" || return 1
        fi

        if ! mkdir -p "$extract"; then
            echo "error: failed to prepare temporary files" >/dev/stderr
            return 1
        fi

        if ! mkdir -p "$packages"; then
            echo "error: failed to prepare temporary files" >/dev/stderr
            return 1
        fi

        local sources=()
        readarray -t sources <<<"$(get_multi_config "$config" "SourcePackages")"

        if (( ${#sources[@]} == 0 )); then
            # nothing to fetch
            return 0
        fi

        updated=()
        for s in "${sources[@]}"; do
            local source="$(trim "${s%% *}")"
            local version=
            local version_action=
            local file="$packages/${source}.rpm"

            if echo "$s" | grep -Pqoe " ([><]=?|=) "; then
                version_action="$(echo "$s" | grep -Poe "([><]=?|=)")"
                version="${s##* }"
            fi

            if [[ -n "$update_local_sources" ]]; then
                [[ "$source" == *":"* ]] && source="${source#*:}"  # remove openrepos user name
                file="$packages/${source}.rpm"
                local local_file="$update_local_sources/$source.rpm"

                if [[ ! -f "$local_file" ]]; then
                    echo "error: local package file '$local_file' not found" >/dev/stderr
                    return 1
                else
                    cp --backup=t "$local_file" "$file"
                fi
            elif [[ "$source" == *":"* ]]; then
                # assume openrepos
                local user="${source%%:*}"
                local source="${source#*:}"
                file="$packages/${source}.rpm"

                if [[ -z "$user" ]]; then
                    echo "error: failed to determine OpenRepos user for '$source'" >/dev/stderr
                    return 1
                fi

                local repo_url="${openrepos_url%/}/${user}/personal/main/${source:0:1}/"
                local html=
                local repo_status="$(curl -LI "$repo_url" 2>/dev/null | head -n 1 | cut -d$' ' -f2)"
                if [[ "$repo_status" != 2[0-9][0-9] ]]; then
                    echo "error: failed to download user \"$user\"'s OpenRepos repository for '$source' (code $repo_status)" >/dev/stderr
                    return 1
                else
                    html="$(curl "$repo_url")"
                fi

                set -o pipefail
                local repo="$(echo "$html" | hxnormalize -x -e | hxselect html body a -s "\n" |\
                    sed -E 's/^<a href=".*?\.rpm">//g;s#</a>##g' |\
                    grep "armv7hl" |\
                    sort --version-sort -u)"

                if (( $? != 0 )); then
                    echo "error: failed to extract OpenRepos repository listing for '$source'" >/dev/stderr
                    return 1
                fi

                local rpms=()
                local versions=()
                readarray -t rpms <<<"$(echo "$repo" | grep "^$source-[0-9]")"
                readarray -t versions <<<"$(echo "$repo" | grep "^$source-[0-9]" | sed "s/^$source-//g" | sed 's/.armv7hl.rpm$//g')"

                local last_selected=
                local rpm_count=0
                for pack in "${rpms[@]}"; do
                    if __update_is_valid_version "$version_action" "${versions[$rpm_count]}" "$version"; then
                        last_selected="$pack"
                    fi
                    ((rpm_count++))
                done

                cd "$packages"
                if ! curl "${repo_url%/}/$last_selected" -o "${source}.rpm"; then
                    echo "error: failed to download package '$source'" >/dev/stderr
                    cd "$base"
                    return 1
                fi
                cd "$base"
            else
                # assume Jolla store
                if [[ -z "$SF_PATCH_SSH_TARGET" ]]; then
                    echo "error: ssh target not set" >/dev/stderr
                    echo "       cannot fetch packages from official repos without ssh access to the device" >/dev/stderr
                    return 1
                fi

                echo "downloading package via external device..."
                remote_temp_dir="/tmp/sailfish-patch.tmp"
                ssh "$SF_PATCH_SSH_TARGET" -o ConnectTimeout=3\
                    "rm -rf '$remote_temp_dir'; mkdir -p '$remote_temp_dir' && pkcon download '$remote_temp_dir' '$source'"

                if (( $? != 0 )); then
                    echo "error: failed to download package '$source' from official repos via ssh" >/dev/stderr
                    return 1
                fi

                scp "$SF_PATCH_REMOTE_USERNAME@$SF_PATCH_SSH_TARGET:$remote_temp_dir/${source}*" "$file"

                if (( $? != 0 )); then
                    echo "error: failed to transfer downloaded package '$source' from the device" >/dev/stderr
                    return 1
                fi
            fi

            if [[ -n "$version" && -n "$version_action" ]]; then
                if ! __update_is_valid_version "$version_action" "$(rpm -qp --queryformat '%{VERSION}' "$file" 2>/dev/null)" "$version"; then
                    echo "error: could not fetch appropriate version of '$source' ($version$version_action$(rpm -qp --queryformat '%{VERSION}' "$file"))" >/dev/stderr
                    return 1
                fi
            fi

            cd "$extract"

            if ! rpm2cpio "$file" | cpio -idmv; then
                echo "error: failed to extract '$file'" >/dev/stderr
                cd "$base"
                return 1
            fi

            updated+=("$file")
            cd "$base"
        done

        cd "$extract"

        prefix="$(get_single_config "$config" "Prefix" "/")"

        if [[ ! -d ".$prefix" ]]; then
            echo "error: invalid prefix $prefix" >/dev/stderr
            cd "$base"
            return 1
        fi

        cd ".$prefix"
        shopt -s nullglob dotglob
        mkdir -p "$original"
        mv -t "$original" * || return 1
        shopt -u nullglob dotglob

        cd "$base"

        printf "\nupdated:\n"
        update_list="$packages/updated"  # TODO documentation
        rm -rf "$update_list"
        for package in "${updated[@]}"; do
            rpm -qp "$package" --qf "- %{NAME}: %{VERSION} (release %{RELEASE}, %{ARCH})\n" | tee -a "$update_list"
        done
        echo

        return 0
    }

    __update_copy_sources() {
        local original="$(__get_original_path)"
        local patched="$(__get_patched_path)"

        if ! rm -rf "$patched"; then
            echo "error: failed to remove old patched sources" >/dev/stderr
            return 1
        fi

        if [[ ! -d "$original" ]]; then
            echo "error: failed to copy sources - files not found" >/dev/stderr
            return 1
        fi

        cp -r "$original" "$patched" || return 1
        return 0
    }

    # we assume config has been checked before and is valid
    __update_apply_diff() { # 1: diff file
        local original="$(__get_original_path)"
        local patched="$(__get_patched_path)"
        local prefix="$(get_single_config "$(__get_config_path)" "Prefix" "/")"
        local tmp_diff="diff_applying.patch"
        local patch_command_file="diff_apply_command.sh"

        local original_backup="$original.tmp"
        local patched_backup="$patched.tmp"

        cp -r "$original" "$original_backup" && cp -r "$patched" "$patched_backup" || {
            echo "fatal: failed to create temporary copy of pre-patched files" >/dev/stderr
            echo "error: manual cleanup required" >/dev/stderr
            return 1
        }

        __update_apply_diff_rollback() {
            rm -rf "$original" "$patched"
            mv "$original_backup" "$original"
            mv "$patched_backup" "$patched"
        }

        if [[ "$prefix" != "/" && "$prefix" != *"/" ]]; then
            prefix="$prefix/"
        fi

        sed "$1" -Ee "s@(--git|---|\+\+\+) a${prefix}@\1 a${original}/@g;
                   s@(--git|---|\+\+\+) b${prefix}@\1 b${patched}/@g;
                   s@(--git a/.*) b${prefix}@\1 b${patched}/@g" > "$tmp_diff" || {
            echo "error: failed to update diff paths" >/dev/stderr
            __update_apply_diff_rollback
            return 1
        }

        strip="$(pwd)"
        strip="${strip%/}/"
        strip="$(echo "$strip" | grep -oe "/" | wc -l)"

        local failed=false
        if [[ "$patch_utility" == "git" ]]; then
            if ! git apply --reject --binary -p "$strip" -v "$tmp_diff"; then
                echo "error: failed to apply diff" >/dev/stderr
                echo -n "patch command: "
                echo "git apply --reject --binary -p '$strip' -v '$tmp_diff'" | tee "$patch_command_file"
                failed=true
            fi
        elif [[ "$patch_utility" == "patch" ]]; then
            if ! patch -p"$strip" -u <"$tmp_diff"; then
                echo "error: failed to apply diff" >/dev/stderr
                echo -n "patch command: "
                echo "patch -p'$strip' -u <'$tmp_diff'" | tee "$patch_command_file"
                failed=true
            fi
        else
            echo "internal error: unknown patch utility '$patch_utility'" >/dev/stderr
            failed=true
        fi

        [[ "$failed" == true ]] && __update_apply_diff_rollback && return 1

        rm -rf "$original" && mv "$original_backup" "$original"
        rm -rf "$patched_backup"
        rm "$tmp_diff"
    }

    if [[ "$import" == true ]]; then
        if git rev-parse --git-dir 2>/dev/null; then
            echo "error: already inside a Git repository;" >/dev/stderr
            echo "       sailfish-patch heavily relies on having only one" >/dev/stderr
            echo "       patch per repo" >/dev/stderr
            exit 1
        fi

        require_config "$import_config" || exit 1

        package="$(get_single_config "$import_config" "PackageName")"
        "$import_command" --create "$package" || exit 1

        cd "$package"
        cp "$import_config" "$(__get_config_path)"

        __update_fetch_latest_sources || exit 1
        __update_copy_sources || exit 1

        # extract tarball
        base="$(pwd)"
        extract_dir=""

        if [[ "$(file --mime-type -b "$import_source")" == "text/x-diff" ]]; then
            echo -n # skip, it is a patch file so we can use it directly
        elif tar -tf "$import_source" >/dev/null 2>/dev/null; then
            # it is a tar file, so we extract it and search for the patch
            extract_dir="$(mktemp -d tmp.XXXX -p .)"
            cd "$extract_dir"
            tar -xzvf "$import_source"

            if [[ ! -f "unified_diff.patch" ]]; then
                echo "error: could not find diff file in tarball" >/dev/stderr
                exit 1
            fi

            cd "$base"
            import_source="$extract_dir/unified_diff.patch"
        else
            echo "error: unrecognized source file" >/dev/stderr
            echo "       Any patch file, or a patch named 'unified_diff.patch' inside" >/dev/stderr
            echo "       a tar archive are supported." >/dev/stderr
            exit 1
        fi

        __update_apply_diff "$import_source" || {
            [[ -n "$extract_dir" ]] && rm -rf "$extract_dir"
            exit 1
        }

        if [[ -n "$extract_dir" ]]; then
            rm -rf "$extract_dir"
        fi

        git add "$(__get_config_path)" "$(__get_original_path)" "$(__get_patched_path)" &&\
            git commit -m "patch automatically imported by sailfish-patch"

        __print_initial_help "$(__get_original_path)" "$(__get_patched_path)" "$(__get_extra_path)"
    fi

    if [[ "$update" == true ]]; then
        original="$(__get_original_path)"
        patched="$(__get_patched_path)"

        # We only allow changed or untracked files that are not in the original/ or patched/ directories.
        if [[ -n "$(git status --porcelain=v1 -z | sed -zEe '/^.. (original|patched)\//!d; /^\?\? /d' | tr '\0' '.')" ]]; then
            tmp_msg="uncommitted source changes found, check original/ and patched/"
            [[ "$force" == true ]] && echo "warning: $tmp_msg" || { echo "error: $tmp_msg" >/dev/stderr; exit 1; }
        fi

        if [[ -n "$(git status --porcelain=v1 -z | sed -zEe '/^\?\? (original|patched)\//!d' | tr '\0' '.')" ]]; then
            tmp_msg="untracked source files found, check original/ and patched/"
            [[ "$force" == true ]] && echo "warning: $tmp_msg" || { echo "error: $tmp_msg" >/dev/stderr; exit 1; }
        fi

        require_config "$(__get_config_path)" || exit 1

        readarray -t sources <<<"$(get_multi_config "$(__get_config_path)" "SourcePackages" "")"

        needs_sources=true
        if (( ${#sources[@]} == 1 )) && [[ -z "$(trim "${sources[0]}")" ]]; then
            if [[ -d "$original" && -n "$(shopt -s nullglob; shopt -s dotglob; echo "$original"/* )" ]]; then
                echo "error: no source packages specified but original source files found" >/dev/stderr
                echo "error: automatic update not possible" >/dev/stderr
                exit 1
            else
                echo "note: no source packages specified" >/dev/stderr
                needs_sources=false
                mkdir -p "$original"
            fi
        fi

        if true; then
            # options: user wants to...
            # 1. bootstrap a distributed patch
            #       - unified_diff.patch exists
            #       - all source dirs are missing
            # 2. update sources of an existing patch
            #       - all source dirs exist
            # 3. bootstrap a newly created patch from its configuration
            #       - all source dirs are missing
            #       - unified_diff.patch is missing

            if [[ "$needs_sources" == true ]] && [[ -z "$(shopt -s nullglob; shopt -s dotglob; echo "$original"/* )" ]]; then
                rm -rf "$original"  # empty
            fi

            if [[ -z "$(shopt -s nullglob; shopt -s dotglob; echo "$patched"/* )" ]]; then
                rm -rf "$patched"  # empty
            fi

            type=update
            latest_commit="$(git rev-parse --verify --short HEAD 2>/dev/null || echo -n "no-git")"
            diff_file="diff_original_${latest_commit}.patch"
            updated_diff="diff_updated_${latest_commit}.patch"
            working_diff="diff_applying.patch"  # same as $tmp_diff in __update_apply_diff!; TODO documentation

            if [[ ! -d "$original" && ! -d "$patched" && ! -f "$working_diff" ]]; then
                if [[ -f "unified_diff.patch" ]]; then
                    echo "note: bootstrapping distribution package" >/dev/stderr
                    diff_file="unified_diff.patch"
                    type=dist_bootstrap
                else
                    echo "note: bootstrapping an empty package" >/dev/stderr
                    type=initial_bootstrap
                fi
            elif [[ ! -d "$original" ]]; then
                echo "error: original files missing" >/dev/stderr
                exit 1
            elif [[ ! -d "$patched" ]]; then
                echo "error: patched files missing" >/dev/stderr
                exit 1
            elif [[ -f "$working_diff" ]]; then
                type=retry
                echo "note: automatic updating failed" >/dev/stderr
                echo "      Make sure both source directories contain updated but unchanged sources." >/dev/stderr
                echo "      Continue by comitting the changed files. Do not reset them if you want to continue." >/dev/stderr
                echo "      Then try to fix the patch in '$working_diff' and re-run the patch command." >/dev/stderr
                echo "      If it fails again, you can checkout the updated sources and try again." >/dev/stderr
                exit 0
            fi

            # make sure all source directories exist
            mkdir -p "$original" "$patched" "$(__get_build_path)"

            case "$type" in
                dist_bootstrap|initial_bootstrap)
                    if [[ "$needs_sources" == true ]]; then
                        __update_fetch_latest_sources "$latest_commit" && __update_copy_sources || {
                            echo "unrolling changes..."
                            rm -rf "$original" "$patched"
                            exit 1
                        }
                    fi

                    if [[ "$type" == dist_bootstrap ]]; then
                        if ! __update_apply_diff "$diff_file"; then
                            echo "error: failed to apply patch to downloaded sources" >/dev/stderr
                            echo "       Both source directories now contain fresh but unchanged sources." >/dev/stderr
                            echo "       The original patch is still available in '$diff_file' and you can" >/dev/stderr
                            echo "       try applying it manually to the files in '$patched'." >/dev/stderr
                            exit 1
                        else
                            __create_diff "$(__get_config_path)" "$updated_diff"
                            if diff <(sed '/^index/d' "$diff_file") <(sed '/^index/d' "$updated_diff") >/dev/null; then
                                # everything worked perfectly
                                rm "$updated_diff"
                            else
                                echo "warning: source patch differs from newly generated patch"
                            fi
                        fi
                    fi
                    __print_initial_help "$(__get_original_path)" "$(__get_patched_path)" "$(__get_extra_path)"
                ;;
                update)
                    diff_file_temp="$(mktemp -p . "$diff_file.XXXXXX")"
                    mv --backup=t -T "$diff_file_temp" "$diff_file"  # make sure we don't overwrite anything
                    __create_diff "$(__get_config_path)" "$diff_file"

                    original_backup="$original-old-${latest_commit}"
                    mv --backup=t -T "$original" "$original_backup"
                    mkdir -p "$original"

                    if [[ "$needs_sources" == true ]]; then
                        __update_fetch_latest_sources "$latest_commit" || {
                            echo "note: unrolling changes..."
                            rm -rf "$original" && mv -T "$original_backup" "$original"
                            exit 1
                        }
                    fi

                    patched_backup="$patched-old-${latest_commit}"
                    mv --backup=t -T "$patched" "$patched_backup"
                    mkdir -p "$patched"

                    if [[ "$needs_sources" == true ]]; then
                        __update_copy_sources || {
                            echo "note: unrolling changes..."
                            rm -rf "$patched" && mv -T "$patched_backup" "$patched"
                            exit 1
                        }
                    fi

                    __update_apply_diff "$diff_file" && rm -f "$working_diff" || {
                        echo "note: the original patch has been saved to '$diff_file'" >/dev/stderr
                        echo "      Both source directories now contain updated but unchanged sources." >/dev/stderr
                        echo "      Continue by comitting the changed files. Do not reset them if you want to continue." >/dev/stderr
                        echo "      Then try to fix the patch in '$working_diff' and re-run the patch command." >/dev/stderr
                        echo "      If it fails again, you can checkout the updated sources and try again." >/dev/stderr
                        exit 1
                    }

                    diff_file_temp="$(mktemp -p . "$updated_diff.XXXXXX")"
                    mv --backup=t -T "$diff_file_temp" "$updated_diff"  # make sure we don't overwrite anything
                    __create_diff "$(__get_config_path)" "$updated_diff"

                    if diff <(sed '/^index/d' "$diff_file") <(sed '/^index/d' "$updated_diff") >/dev/null; then
                        echo "success: old and new patch files are identical"
                        echo "         you can remove the backup copies now"
                    else
                        echo "warning: updated patch file has changed" >/dev/stderr
                    fi
                ;;
                *) echo "error: invalid update type '$type'" >/dev/stderr && exit 1;;
            esac
        fi
    fi

    if [[ "$optimize_screenshots" == true ]]; then
        __show_stats() { # 1: title, 2: osize, 3: nsize
            local osize="$2"
            local nsize="$3"
            local change="$((nsize-osize))"
            local state=""

            if ((change > 0)); then
                state="+$(echo "$change" | numfmt --to=iec)"
            elif ((change == 0)); then
                state="no change"
            else
                state="$(echo "$change" | numfmt --to=iec)"
            fi

            echo "$1: $(echo "$osize" | numfmt --to=iec) => $(echo "$nsize" | numfmt --to=iec) ($state)"
        }

        require_config "$(__get_config_path)" || exit 1
        readarray -t screenshots <<<"$(get_multi_config "$(__get_config_path)" "Screenshots")"

        if [[ -z "$optimize_screenshots_runs" ]]; then
            optimize_screenshots_runs=1
        else
            screen_add=" ($optimize_screenshots_runs rounds)"
        fi

        echo "optimizing screenshots$screen_add..."

        screen_files=()
        old_size=0
        for s in "${screenshots[@]}"; do
            screen="$s"
            [[ ! -f "$s" ]] && screen="$(dirname "$config")/$s"
            screen_files+=("$screen")
            old_size=$(( old_size + $(du -bs "$screen" | grep -Poe '^\d+') ))
        done

        last_size=$old_size
        for i in $(seq 1 "$optimize_screenshots_runs"); do
            (( $optimize_screenshots_runs > 1 )) && echo "round $i / $optimize_screenshots_runs..."
            new_size=0
            for s in "${screen_files[@]}"; do
                convert -resize 1200x1200\> "$s" "$s-resized.png"
                pngcrush "$s-resized.png" "$s-crushed.png" && pngquant "$s-crushed.png"
                mv "$s-crushed-fs8.png" "$s"
                rm "$s-resized.png" "$s-crushed.png"
                new_size=$(( new_size + $(du -bs "$s" | grep -Poe '^\d+') ))
            done

            (( $optimize_screenshots_runs > 1 )) && __show_stats "round $i" "$last_size" "$new_size"
            last_size="$new_size"
            unset screen
        done

        new_size=0
        for s in "${screen_files[@]}"; do
            new_size=$(( new_size + $(du -bs "$s" | grep -Poe '^\d+') ))
        done

        __show_stats "screenshots optimized" "$old_size" "$new_size"
    fi

    if [[ "$build" == true ]]; then
        # require valid config and build directory
        require_build_config || exit 1
        base="$(pwd)"
        config="$(__get_config_path)"
        build_dir="$(__get_build_path)"
        extra_dir="$(__get_extra_path)"
        original="$(__get_original_path)"
        patched="$(__get_patched_path)"

        # require original files
        if [[ ! -d "$original" ]]; then
            echo "note: creating empty original files directory" >/dev/stderr
            mkdir -p "$original" || {
                echo "error: failed to create empty original files directory" >/dev/stderr
                echo "       Even if the patch only adds files, the 'original'" >/dev/stderr
                echo "       directory has to be present." >/dev/stderr
                exit 1
            }
        fi

        if [[ ! -d "$patched" && ! -d "$extra_dir" ]]; then
            # patches may only add a settings page, so the patched directory is only
            # a hard requirement when no extra files are added
            echo "error: missing patched files directory" >/dev/stderr
            exit 1
        else
            mkdir -p "$patched" || {
                echo "error: failed to create empty patched files directory" >/dev/stderr
                exit 1
            }
        fi

        # verify extra files (imported later, so we don't have to clean up if something fails)
        if [[ -d "$extra_dir" ]]; then
            if (( $(find "$extra_dir" -mindepth 1 -type d | wc -l) > 0 )); then
                echo "error: subdirectories are not allowed for extra files" >/dev/stderr
                exit 1
            fi

            if find "$extra_dir" -type f -print0 | tr -d '\n' | tr '\0' '\n' | grep -Pqve "\.(qml|js|png|svg|qm)$"; then
                echo "error: unsupported extra files found" >/dev/stderr
                echo "       Only files with the following extensions are allowed:" >/dev/stderr
                echo "          .qml, .js, .png, .svg, .qm" >/dev/stderr
                exit 1
            fi

            langs="$(find "$extra_dir" -type f -iname "*.qm" -execdir printf "%s\0" {} \; | tr '\n' '%' | tr '\0' '\n')"
            if [[ -n "$langs" ]] && echo "$langs" | grep -Pqve "^./translation_[a-zA-Z_]{2,5}.qm$"; then
                echo "error: invalid translation file names found" >/dev/stderr
                echo "       Translation files must follow the format 'translation_LANG.qm'." >/dev/stderr
                exit 1
            fi

            qmls="$(find "$extra_dir" -type f -iname "*.qml" -print0 | tr '\n' '\t' | tr '\0' '\n')"
            if [[ -n "$qmls" ]] && ! echo "$qmls" | grep -Pqe '/main.qml$'; then
                echo "error: extra QML files found but no main file" >/dev/stderr
                echo "       A file named 'main.qml' must be provided" >/dev/stderr
                echo "       when including extra QML files." >/dev/stderr
                exit 1
            fi
        fi

        # create temp dir
        temp_build_dir="$(mktemp -d -p "$build_dir" build.XXXX)"

        # import extra files
        if [[ -d "$extra_dir" && -n "$(shopt -s nullglob; shopt -s dotglob; echo "$extra_dir"/* )" ]]; then
            if (( $(find "$extra_dir" -type f -iregex ".*\.\(qml\|js\|png\|svg\|qm\)$" | wc -l) > 0 )); then
                mkdir -p "$temp_build_dir/extra"
                find "$extra_dir" -type f -iregex ".*\.\(qml\|js\|png\|svg\|qm\)$" -exec cp {} "$temp_build_dir/extra" \;
            else
                echo "warning: directory for extra files found but there are no usable files"
            fi
        fi

        # create diff
        __create_diff "$config" "${temp_build_dir}/unified_diff.patch"

        cd "$temp_build_dir" # important: switch to temp_build_dir

        # prepare files and templates
        rpm_build_dir="$temp_build_dir/rpm_build"
        tarball_build_dir="$temp_build_dir/tarball_build"
        dist_build_dir="$temp_build_dir/dist_build"

        mkdir -p "$rpm_build_dir" "$tarball_build_dir" "$dist_build_dir"

        __save_template_spec rpm.spec
        __save_template_json "$rpm_build_dir/patch.json"

        if [[ -d extra && -n "$(shopt -s nullglob; shopt -s dotglob; echo extra/* )" ]]; then
            cp extra/* "$rpm_build_dir"
            mkdir -p "$dist_build_dir/extra" && cp extra/* "$dist_build_dir/extra"
            mv extra/* "$tarball_build_dir"
        fi

        cp unified_diff.patch "$rpm_build_dir/unified_diff.patch"
        cp unified_diff.patch "$dist_build_dir/unified_diff.patch"
        mv unified_diff.patch "$tarball_build_dir/unified_diff.patch"

        if [[ -f "$base/COPYING" ]]; then
            cp "$base/COPYING" "$dist_build_dir"
        fi

        cp "$config" "$dist_build_dir"
        readarray -t screenshots <<<"$(get_multi_config "$config" "Screenshots")"

        for s in "${screenshots[@]}"; do
            if [[ -f "$s" || -f "$(dirname "$config")/$s" ]]; then
                [[ -f "$s" ]] && cp "$s" "$dist_build_dir" || cp "$(dirname "$config")/$s" "$dist_build_dir"
                s="${s//\//\\/}" # escape slashes
                sed -E -i "s/-[ \t]*$s$/- $(basename "$s")/g" "$dist_build_dir/$(basename "$config")"
            fi
        done

        rpm_version="$(get_single_config "$config" "Version")"
        release="$(get_single_config "$config" "Release")"
        package="$(get_single_config "$config" "PackageName")"
        echo "building version: $rpm_version-$release"

        # configure spec and json files
        for i in PackageName Summary Version Release Maintainer DisplayName Category DiscussionLink DonationsLink SourcesLink; do
            value="$(get_single_config "$config" "$i")"
            [[ -z "$value" ]] && value="" # empty values will be left empty

            value="${value//\//\\/}" # escape slashes
            sed -i "s/@${i^^}@/$value/g" rpm.spec
            sed -i "s/@${i^^}@/$value/g" "$rpm_build_dir/patch.json"
        done

        # configure json-specific fields
        description="$(get_multi_config "$config" "Description")"
        description="${description//\"/\\\\\"}" # escape quotes
        description="${description//&/\\\\&}" # escape ampersand
        awk -v r="$description" '{gsub(/@DESCRIPTION@/,r)}1'\
            "$rpm_build_dir/patch.json" > _tmp && mv _tmp "$rpm_build_dir/patch.json"

        # configure rpm-specific fields
        for i in Requires Obsoletes Conflicts; do
            values="$(get_multi_config "$config" "$i")"

            if [[ -n "$values" ]]; then
                readarray -t m_lines <<<"$(echo "$values")"

                for l in "${m_lines[@]}"; do
                    l="${l//\//\\/}" # escape slashes
                    sed -i "$(echo -en "/@${i^^}@/i\\\\\n$i: $l")" rpm.spec
                done
            fi

            sed -i "s/@${i^^}@//g" rpm.spec
        done

        # build rpm
        echo "building RPM..."
        rpmbuild -bb --build-in-place rpm.spec --define "_rpmdir $(pwd)/RPMS"

        if (( $? != 0 )); then
            echo "error: failed to build RPM" >/dev/stderr
        else
            mv --backup=t RPMS/**/*.rpm "$build_dir"
            echo "success: RPM built"
        fi

        # build tarball
        echo "building tarball..."
        cd "$tarball_build_dir"
        tarball="$package-$rpm_version-$release.tar.gz"
        tar -czvf "$tarball" *

        if (( $? != 0 )); then
            echo "error: failed to build tarball" >/dev/stderr
        else
            echo "success: tarball built"
            mv --backup=t "$tarball" "$build_dir"
        fi

        # build code distribution package
        echo "building code distribution package..."
        mv "$dist_build_dir" "$package" &&\
            mv --backup=t "$package" "$build_dir"

        if (( $? != 0 )); then
            echo "error: failed to build code distribution package" >/dev/stderr
        else
            echo "success: code distribution package built"
        fi

        # clean up
        rm -r "$temp_build_dir"
        cd "$base"
    fi

    if [[ "$publish_via_ssh" == true ]]; then
        echo "deploying patch..."
        require_current_package rpm || exit 1
        rpm="$(__get_package_path rpm)"
        echo "package: $rpm"

        if [[ ! -f "$SF_PATCH_PASSFILE" ]]; then
            echo "error: passphrase file not found" >/dev/stderr
            exit 2
        fi

        config="$(__get_config_path)" # we assume it has been checked before
        package_name="$(get_single_config "$config" "PackageName")"

        scp "$rpm" "$SF_PATCH_REMOTE_USERNAME@$SF_PATCH_SSH_TARGET:$SF_PATCH_REMOTE_PATH"
        { { head -1 "$SF_PATCH_PASSFILE" | ssh -o ConnectTimeout=3 "$SF_PATCH_SSH_TARGET" "devel-su /usr/sbin/patchmanager -u '$package_name'"; } || {
            echo "error: failed to ensure patch is unapplied" >/dev/stderr && false
        }; } &&\
        { { head -1 "$SF_PATCH_PASSFILE" | ssh -o ConnectTimeout=3 "$SF_PATCH_SSH_TARGET" "if rpm -q '$package_name'; then devel-su rpm --erase '$package_name'; else true; fi;"; } || {
            echo "error: failed to ensure patch package is not installed" >/dev/stderr && false
        }; } &&\
        { { head -1 "$SF_PATCH_PASSFILE" | ssh -o ConnectTimeout=3 "$SF_PATCH_SSH_TARGET" "devel-su rpm -ivh '$SF_PATCH_REMOTE_PATH/$(basename "$rpm")'"; } || {
            echo "error: failed to install patch package" >/dev/stderr && false
        }; } &&\
        { { head -1 "$SF_PATCH_PASSFILE" | ssh -o ConnectTimeout=3 "$SF_PATCH_SSH_TARGET" "devel-su /usr/sbin/patchmanager -a '$package_name'"; } || {
            echo "error: failed to apply patch" >/dev/stderr && false
        }; }

        install_success=$?

        needs_keyboard="$(get_multi_config "$config" "Requires" | paste -s -d'\n' - <(get_multi_config "$config" "SourcePackages") | grep -oe '^jolla-keyboard')"
        if [[ -n "$needs_keyboard" ]]; then
            echo "restarting keyboard service..."
            head -1 "$SF_PATCH_PASSFILE" | ssh -o ConnectTimeout=3 "$SF_PATCH_SSH_TARGET" "devel-su systemctl --user restart maliit-server" || {
                echo "warning: failed to restart keyboard service (maliit-server)" >/dev/stderr && false
            }
        fi

        if (( $install_success > 0 )); then
            echo "failed to deploy patch" >/dev/stderr
        else
            echo "patch deployed"
        fi
    fi

    __wizard_load() { # 1: type, 2: title, 3: key
        local config="$(__get_config_path)" # we assume it has been checked before

        if [[ "${1:0:1}" == "s" ]]; then
            local value="$(get_single_config "$config" "$3")"
        else
            local value="$(get_multi_config "$config" "$3")"
        fi

        echo -n "$value" | xclip -selection c

        if [[ "${1:0:1}" == "s" ]]; then
            read -n 1 -s -p "$2: $value"; echo
        else
            read -n 1 -s -p "$2:
$value"
            echo
        fi

    }

    __wizard_load_screenshots() {
        local config="$(__get_config_path)" # we assume it has been checked before
        local first_path="$(get_multi_config "$config" "Screenshots" | head -1)"

        if [[ "${first_path:0:1}" == "/" ]]; then
            local screenshots_path="$(readlink -m "$(dirname "$first_path")")"
        elif [[ -n "$first_path" ]]; then
            # relative paths are relative to the config file
            local screenshots_path="$(readlink -m "$(dirname "$(__get_config_path)")")"
        else
            local screenshots_path=
        fi

        echo -n "$screenshots_path" | xclip -selection c
        read -n 1 -s -p "Screenshots (first directory path): $screenshots_path"; echo
    }

    __wizard_load_changelog() { # 1: target ('openrepos' or 'catalogue')
        local config="$(__get_config_path)" # we assume it has been checked before
        local changelog="$(get_multi_config "$config" "Changelog")"

        if [[ "$1" == "openrepos" ]]; then
            # put each paragraph separated by a blank line into <p> tags,
            # end each line with <br>
            readarray -t changelog_lines <<<"$changelog"
            changelog=

            local in_paragraph=false
            for l in "${changelog_lines[@]}"; do
                l="$(trim "$l")"

                if [[ -n "$l" ]]; then
                    if [[ "$in_paragraph" == false ]]; then
                        in_paragraph=true
                        changelog+="<p>"
                    fi
                    changelog+="$l<br>"
                else
                    if [[ "$in_paragraph" == true ]]; then
                        changelog="${changelog%<br>}</p>
" # newline intended
                    fi
                    in_paragraph=false
                fi
            done
        fi

        echo -n "$changelog" | xclip -selection c

        read -n 1 -s -p "Changelog:
$changelog"  # newline intended
        echo
    }

    __wizard_load_description() { # 1: target ('openrepos' or 'catalogue')
        local config="$(__get_config_path)" # we assume it has been checked before
        local description="$(get_multi_config "$config" "Description")"

        # - put each paragraph separated by a blank line into <p> tags
        readarray -t description_lines <<<"$description"
        description=

        local in_paragraph=false
        for l in "${description_lines[@]}"; do
            l="$(trim "$l")"

            if [[ -n "$l" ]]; then
                if [[ "$in_paragraph" == false ]]; then
                    in_paragraph=true
                    description+="<p>"
                fi
                description+="$l "
            else
                if [[ "$in_paragraph" == true ]]; then
                    description="${description% }</p>
" # newline intended
                fi
                in_paragraph=false
            fi
        done

        # html-ify links and very basic highlighting
        description="$(echo "$description" |\
            perl -p0e 's/\[(.*?)\]\((.+?)\)/<a href="\2">\1<\/a>/g' |\
            perl -p0e 's/\B\*\*(.+?)\*\*\B/<b>\1<\/b>/g; s/\b_?_(.+?)_?_\b/<u>\1<\/u>/g; s/\B\*(.+?)\*\B/<i>\1<\/i>/g')"

        if [[ "$1" == "openrepos" ]]; then
            # append extra links
            local sources_link="$(get_single_config "$config" "SourcesLink")"
            local discussion_link="$(get_single_config "$config" "DiscussionLink")"
            local donations_link="$(get_single_config "$config" "DonationsLink")"

            for l in "Sources:$sources_link" "Discussion:$discussion_link" "Donations:$donations_link"; do
                if [[ -n "${l#*:}" ]]; then
                    description="$description
<p>${l%%:*}: <a href=\"${l#*:}\">${l#*:}</a></p>"
                fi
            done
        elif [[ "$1" == "catalogue" ]]; then
            # Translate html tags (back) to plain text; links are replaced by an in-text representation.
            # This back-and-forth makes sure everything is properly cleaned up.
            description="$(echo "$description" | html2text -b 0 --reference-links --no-wrap-links | perl -p0e 's/\[(.*?)\]\[([0-9]+)\]/\1 (\2)/g')"
        else
            echo "internal error: invalid description target given ('$1')" >/dev/stderr
        fi

        echo -n "$description" | xclip -selection c

        read -n 1 -s -p "Description:
$description"  # newline intended
        echo
    }

    if [[ "$publish_to_openrepos" == true ]]; then
        echo "running wizard for publishing to OpenRepos..."
        echo "Each value will be copied to the clipboard. Press any key to load the"
        echo "next value."
        echo
        require_current_package rpm || exit 1
        rpm="$(__get_package_path rpm)"
        config="$(__get_config_path)" # safe because we already checked above
        name="$(get_single_config "$config" "DisplayName")"

        if [[ "$publish_update_only" == true ]]; then
            echo "Patch: $name"
        else
            echo -n "Patch: $name" | xclip -selection c
            read -n 1 -s -p "Application name: Patch: $name"; echo

            echo -n "Applications -> Patches" | xclip -selection c
            read -n 1 -s -p "Category: Applications -> Patches"; echo

            readarray -t keywords <<<"$(get_multi_config "$config" "Keywords")"
            for i in "${keywords[@]}"; do
                echo -n "$i" | xclip -selection c
                read -n 1 -s -p "Keyword: $i"; echo
            done

            icon_file="/tmp/sailfish-patch_icon.png"
            __save_template_icon "$icon_file"
            echo -n "$icon_file" | xclip -selection c
            read -n 1 -s -p "Icon: $icon_file"; echo

            __wizard_load s "Summary" "Summary"
            __wizard_load_description "openrepos"
            __wizard_load_screenshots
        fi

        echo -n "$rpm" | xclip -selection c
        read -n 1 -s -p "Application version: $rpm"; echo

        __wizard_load_changelog openrepos
    fi

    if [[ "$publish_to_pm_catalogue" == true ]]; then
        echo "running wizard for publishing to Patchmanager's online catalogue..."
        echo "Each value will be copied to the clipboard. Press any key to load the"
        echo "next value."
        echo
        require_current_package tarball || exit 1
        config="$(__get_config_path)" # safe because we already checked above
        tarball="$(__get_package_path tarball)"

        if [[ "$publish_update_only" == true ]]; then
            echo "Patch: $(get_single_config "$config" "DisplayName")"
        else
            __wizard_load s "Internal name" "PackageName"
            __wizard_load s "Display name" "DisplayName"
            __wizard_load_description "catalogue"
            __wizard_load s "Category" "Category"
            __wizard_load s "Discussion link" "DiscussionLink"
            __wizard_load s "Donations link" "DonationsLink"
            __wizard_load s "Sources link" "SourcesLink"
            __wizard_load_screenshots
        fi

        __wizard_load s "Version" "Version"
        __wizard_load m "Compatible versions" "CompatibleVersions"
        echo -n "$tarball" | xclip -selection c
        read -n 1 -s -p "Patch archive: $tarball"; echo

        if [[ "$publish_update_only" == true ]]; then
            full_changelog="$(get_multi_config "$config" "Changelog")"
            version="$(get_single_config "$config" "Version")"
            update_changelog="$(echo "$full_changelog" | select_range "^[*]?.*?${version//./\.}.*?:" "^[*]?.*?[0-9]+.*?:")"
            echo -n "$update_changelog" | xclip -selection c

            read -n 1 -s -p "Changelog:
$update_changelog"
            echo
        else
            __wizard_load_changelog catalogue
        fi

        echo done
    fi
fi

if (( ${#debug_export_template[@]} > 0 )); then
    # __save_file() { # 1: file name
    #     if [[ -f "$1" ]]; then  # make sure we don't overwrite anything
    #         file_temp="$(mktemp -p . sailfish-patch-XXXX.tmp)"
    #         mv --backup=t -T "$file_temp" "$1" && rm "$1"
    #     fi
    #     echo "$1"
    # }

    for i in "${debug_export_template[@]}"; do
        case "$i" in
            config) __save_template_config /dev/stdout;;        # "$(__save_file "CONFIG.template")";;
            license) __save_template_copying /dev/stdout;;      # "$(__save_file "COPYING")";;
            gitignore) __save_template_gitignore /dev/stdout;;  # "$(__save_file ".$i")";;
            icon) __save_template_icon /dev/stdout;;            # "$(__save_file "$i.png")";;
            json) __save_template_json /dev/stdout;;            # "$(__save_file "$i.json")";;
            spec) __save_template_spec /dev/stdout;;            # "$(__save_file "$i.spec")";;
        esac
    done
fi
