#!/bin/bash
# kate: syntax bash
#
# sailfish-patch 2.0.0 (2019-06-29)
# Copyright (C) 2016  Cornerman (https://github.com/cornerman/sailfish-patch)
#               2018-2019  Mirian Margiani
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#

DEPENDENCIES=(git sed scp ssh rpmbuild xclip tar hxselect hxnormalize rpm2cpio cpio rpm patch)

# check environment variables
publish_via_ssh_possible=true
if [[ -z "$SF_PATCH_PASSFILE" ]]; then
    publish_via_ssh_possible=false
fi

if [[ -z "$SF_PATCH_SSH_TARGET" ]]; then
    publish_via_ssh_possible=false
fi

if [[ -z "$SF_PATCH_REMOTE_PATH" ]]; then
    SF_PATCH_REMOTE_PATH="/home/nemo"
fi

dependencies() { # 1: echo/no-echo
    local ret=0
    local print=
    if [[ "$1" == "echo" ]]; then
        print=true
        echo -e "\nDependencies:"
    fi

    for i in "${DEPENDENCIES[@]}"; do
        if which "$i" 2> /dev/null >&2; then
            if [[ -n "$print" ]]; then
                echo "    - $i: $(which "$i")"
            fi
        else
            if [[ -n "$print" ]]; then
                echo "    - $i: missing"
                ret=1
            else
                return 1
            fi
        fi
    done

    return "$ret"
}

version() {
    echo "\
sailfish-patch 2.0.0 (2019-06-29)
Copyright (C) 2016  Cornerman
              2018-2019  Mirian Margiani
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law."
    dependencies echo
}

if ! dependencies no-echo; then
    version
    echo -e "\nerror: missing dependencies" >/dev/stderr
    exit 255
fi

show_help() {
local script="$(basename "$0")"
    echo "\
** sailfish-patch **

Manage your SailfishOS patches.

Create a new patch skeleton with '-c NAME' and put the original files
in the directory 'original'. Copy everything to the directory 'patched' and
make your changes. Configure the project in 'build/CONFIG'. Build with '-b'.

Note: separate settings pages are currently only supported via Patchmanager.

Usage:
    $script -c NAME
    $script [-u] [-b] [-p] [-Po] [-Pm]
    $script -C FILE
    $script [-h] [-V]

Arguments:
    -c, --create NAME           - create new patch skeleton in NAME
    -C, --check-config FILE     - validate config file FILE
    -i, --import CONFIG TARBALL - setup a new working directory for the given patch
    -b, --build                 - build RPM and tarball
    -u, --update                - update the working directory with the
                                  latest sources (needs working ssh connection
                                  for all sources except OpenRepos)
    -f, --force                 - skip some safety checks
    -p, --publish-ssh           - publish and install patch on your device via ssh
    -Po, --publish-openrepos    - wizard for publishing in OpenRepos
    -Pm, --publish-patchmanager - wizard for publishing in PM's online catalogue

    -V, --version               - show version and license information
    -h, --help                  - show this help and exit

Debug Options:
    -g, --use-git-apply         - use git-apply(1) instead of patch(1) for applying
                                  the patch (see -i and -u)

Environment:
    - path to a local file containing your devel-su passphrase
        SF_PATCH_PASSFILE=$SF_PATCH_PASSFILE
    - how to connect to your device via ssh (config name or IP)
        SF_PATCH_SSH_TARGET=$SF_PATCH_SSH_TARGET
    - path to a directory where patch RPMs will be stored on your device
        SF_PATCH_REMOTE_PATH=$SF_PATCH_REMOTE_PATH
"
}

check_config=false
check_config_name=
create_new=false
create_new_name=
build=false
update=false
import=false
import_config=
import_tarball=
import_command="$0"
publish_via_ssh=false
publish_to_openrepos=false
publish_to_pm_catalogue=false
force=false
patch_utility=patch

while [[ $# > 0 ]]; do
    case "$1" in
        --help|-h) show_help; exit 0;;
        --version|-V) version; exit 0;;
        -C|--check-config)
            check_config=true
            shift

            if [[ -z "$1" ]]; then
                echo "error: no config file name given" >/dev/stderr
                exit 2
            else
                check_config_name="$1"
            fi
        ;;
        -f|--force) force=true;;
        -c|--create)
            create_new=true
            shift

            if [[ -z "$1" ]]; then
                echo "error: no name for the new patch directory given" >/dev/stderr
                exit 1
            else
                create_new_name="$1"
            fi
        ;;
        -b|--build) build=true;;
        -u|--update) update=true;;
        -i|--import)
            import=true
            shift

            if [[ -z "$1" ]]; then
                echo "error: no config file for the import given" >/dev/stderr
                exit 1
            elif [[ ! -f "$1" ]]; then
                echo "error: config file to be imported not found" >/dev/stderr
                exit 1
            else
                # save absolute path
                import_config="$(readlink -m "$(dirname "$1")")/$(basename "$1")"
            fi

            shift
            if [[ -z "$1" ]]; then
                echo "error: no tarball for the import given" >/dev/stderr
                exit 1
            elif [[ ! -f "$1" ]]; then
                echo "error: tarball to be imported not found" >/dev/stderr
                exit 1
            else
                # save absolute path
                import_tarball="$(readlink -m "$(dirname "$1")")/$(basename "$1")"
            fi
        ;;
        -p|--publish-ssh)
            if [[ "$publish_via_ssh_possible" == false ]]; then
                echo "error: environment not set up correctly for publishing via ssh" >/dev/stderr
                exit 1
            else
                publish_via_ssh=true
            fi
        ;;
        -Po|--publish-openrepos) publish_to_openrepos=true;;
        -Pm|--publish-patchmanager) publish_to_pm_catalogue=true;;
        -g|--use-git-apply) patch_utility=git;;
        -*) echo "unknown option: $1";;
        *) shift; continue;;
    esac
    shift
done

check_categories="Homescreen
Browser
Camera
Calendar
Clock
Contacts
Email
Gallery
Media
Messages
Phone
Silica
Settings
Keyboard
Others"

check_versions="1.1.9.30
2.0.2.51
2.0.4.14
2.0.5.6
2.1.0.11
2.1.1.12
2.1.1.23
2.1.1.24
2.1.1.26
2.1.2.3
2.1.3.3
2.1.3.5
2.1.3.7
2.1.4.13
2.1.4.14
2.1.4.15
2.2.0.29
2.2.1.18
2.2.1.19
3.0.0.5
3.0.0.8
3.0.0.11
3.0.1.11
3.0.1.14
3.0.2.8
3.0.3.8
3.0.3.9
3.0.3.10"

declare -A check_defaults=(
[SourcePackages]="username:source-package-from-openrepos <= 1.0.10|source-package-from-official-repo"
[Prefix]=""
[DisplayName]="Pretty Name"
[PackageName]="sfos-patch-category-name"
[Category]=""
[Keywords]=""
[Maintainer]="username"
[Summary]="short summary for package managers"
[Description]="long description for the store|possibly spanning over multiple lines"
[DiscussionLink]="https://example.org/discussion"
[DonationsLink]="https://example.org/donations"
[SourcesLink]="https://example.org/sources"
[Version]=""
[Release]=""
[Requires]="another-required-package"
[Conflicts]="my-conflicting-package = 0.0.1|the-old-name"
[Obsoletes]="the-other-old-name"
[Screenshots]=""
[CompatibleVersions]=""
[Changelog]=""
)

trim() {
    local var="$*"
    var="${var#"${var%%[![:space:]]*}"}"
    var="${var%"${var##*[![:space:]]}"}"
    echo -n "$var"
}

if [[ "$check_config" == true ]]; then
    if [[ ! -f "$check_config_name" ]]; then
        echo "error: could not find configuration file" >/dev/stderr
        exit 2
    fi

    # check keys and references, files, screenshots
    __check_default_value() { # 1: key, 2: value to check, 3: line
        local key="$1"
        local value="$2"
        local line="$3"

        if [[ -z "$value" ]]; then
            return 0
        fi

        if echo "$value" | grep -Pqoe "@[^ ]+@"; then
            echo "error: field '$key' is not configured ($value; line $line)"
            return 1
        fi

        if [[ -z "${check_defaults[$key]}" ]]; then
            return 0
        elif echo "${check_defaults[$key]}" | sed 's/|/\n/g' |\
                grep -Pqoe "^$(echo "$value" | sed 's/[][\.|$(){}?+*^]/\\&/g')"; then
            echo "error: field '$key' still contains a dummy value (line $line)"
            return 1
        else
            return 0
        fi
    }

    error=false
    count=0
    keys_found=()

    is_multiline=
    is_multiline_at=0
    is_multiline_required=false
    lines_for_multi=0

    while IFS='' read -r line || [[ -n "$line" ]]; do
        count="$((count+1))"
        line="$(trim "$line")"
        key="${line%%:*}"
        value="$(trim "${line#$key:}")"

        if [[ -z "$line" ]]; then
            continue
        elif [[ "$line" == "#"* ]]; then
            continue
        fi

        if [[ -n "$is_multiline" ]] && [[ "$line" == "-"* ]]; then
            lines_for_multi="$((lines_for_multi+1))"
            value="$(trim "${value#-}")"

            # BEGIN value checks for multi line fields
            __check_package_specification() { # 1: error name
                if ! echo "$value" | grep -Pqe "^([^: ]+:|)[^: ]+( (<|>|=|<=|>=) .+|)$"; then
                    echo "error: invalid $is_multiline package specification '$value' (line $count)" >/dev/stderr
                    error=true
                fi
            }

            if [[ "$is_multiline" == "Screenshots" ]]; then
                if [[ ! -f "$value" ]] && [[ ! -f "$(dirname "$check_config_name")/$value" ]]; then
                    echo "error: screenshot file '$value' not found (line $count)" >/dev/stderr
                    error=true
                fi
            elif [[ "$is_multiline" == "CompatibleVersions" ]]; then
                if ! echo "$check_versions" | grep -Pqoe "^$value"; then
                    echo "error: invalid version '$value' (line $count)" >/dev/stderr
                    error=true
                fi
            elif [[    "$is_multiline" == "SourcePackages"
                    || "$is_multiline" == "Requires"
                    || "$is_multiline" == "Obsoletes"
                    || "$is_multiline" == "Conflicts"
            ]]; then
                __check_package_specification
            fi
            # END value checks for multi line fields

            if ! __check_default_value "$is_multiline" "$value" "$count"; then
                error=true
            fi

            continue
        fi

        if [[ "$line" != *":"* ]]; then
            echo "warning: comment lines should start with '#' (line $count)"
            continue
        fi

        if [[ -n "$is_multiline" ]]; then
            if (( lines_for_multi == 0 )); then
                echo "warning: empty multi-line field '$is_multiline' at line $is_multiline_at"

                if [[ "$is_multiline_required" == true ]]; then
                    echo "error: required field '$key' is empty" >/dev/stderr
                    error=true
                fi
            fi

            is_multiline=
            is_multiline_at=0
            lines_for_multi=0
            is_multiline_required=false
        fi

        # BEGIN value checks for single line fields
        # single line
        is_single=true
        case "$key" in
            Prefix|DiscussionLink|DonationsLink|SourcesLink)
                # may be empty
                if [[ -z "$value" ]]; then
                    echo "note: no value given for '$key'"
                else
                    # special rules
                    if [[ "$key" == "Prefix" ]]; then
                        if [[ "$value" != "/"* ]]; then
                            echo "error: prefix must be an absolute path ($value; line $count)"
                            error=true
                        fi
                    fi
                fi
            ;;
            DisplayName|Maintainer|Summary)
                # must not be empty
                if [[ -z "$value" ]]; then
                    echo "error: required field '$key' is empty" >/dev/stderr
                    error=true
                fi
            ;;
            PackageName)
                # must not be empty
                if [[ -z "$value" ]]; then
                    echo "error: required field '$key' is empty" >/dev/stderr
                    error=true
                fi
                # needs special rules
                if echo "$value" | grep -Pqoe "[^a-zA-Z0-9-_]"; then
                    echo "error: package name contains invalid characters (line $count)" >/dev/stderr
                    echo "       allowed are: a-z, A-Z, 0-9, -, _ (no spaces)"
                    error=true
                elif echo "$value" | grep -Pqoe "^[-_]"; then
                    echo "error: package name must not start with '-' or '_' (line $count)" >/dev/stderr
                    error=true
                elif [[ "$value" == "${check_defaults[$key]}" ]]; then
                    echo "error: package name not set (line $count)" >/dev/stderr
                    error=true
                fi
            ;;
            Category)
                # must not be empty
                if [[ -z "$value" ]]; then
                    echo "error: required field '$key' is empty" >/dev/stderr
                    error=true
                fi
                # needs special rules
                if ! echo "$check_categories" | grep -Pqoe "^$value"; then
                    echo "error: invalid category '$value' on line $count" >/dev/stderr
                    error=true
                fi
            ;;
            Version)
                # must not be empty
                if [[ -z "$value" ]]; then
                    echo "error: required field '$key' is empty" >/dev/stderr
                    error=true
                fi
                # needs special rules
                if ! echo "$value" | grep -Pqoe '^[0-9]+\.[0-9]+\.[0-9]+'; then
                    echo "error: version number must consist of three numbers separated by dots (X.Y.Z; line $count)" >/dev/stderr
                    error=true
                fi
            ;;
            Release)
                # must not be empty
                if [[ -z "$value" ]]; then
                    echo "error: required field '$key' is empty" >/dev/stderr
                    error=true
                fi
                # needs special rules
                if ! echo "$value" | grep -Pqoe '^[1-9][0-9]*'; then
                    echo "error: release number must be exactly one number without leading zeros (XYZ; line $count)" >/dev/stderr
                    error=true
                fi
            ;;
            *) is_single=false;;
        esac
        # END value checks for single line fields

        # multi line
        if [[ "$is_single" == false ]]; then
            case "$key" in
                SourcePackages|Screenshots|Changelog|Requires|Keywords|Conflicts|Obsoletes)
                    # regular fields
                    is_multiline="$key"
                    is_multiline_at="$count"
                ;;
                Description|CompatibleVersions)
                    # required fields
                    is_multiline="$key"
                    is_multiline_at="$count"
                    is_multiline_required=true
                ;;
                *)  echo "error: invalid key '$key' on line $count" >/dev/stderr
                    error=true
                ;;
            esac
        fi

        if ! __check_default_value "$key" "$value" "$count"; then
            error=true
        fi

        if printf "%s\n" "${keys_found[@]}" | grep -Pqoe "^$key"; then
            echo "error: field '$key' is defined more than once (line $count)" >/dev/stderr
            error=true
        else
            keys_found+=("$key")
        fi
    done < "$check_config_name"

    # check for required fields
    for r in DisplayName PackageName Category Maintainer Summary Version Release Description CompatibleVersions; do
        if ! printf "%s\n" "${keys_found[@]}"  | grep -Pqoe "^$r"; then
            echo "error: required field '$r' is missing" >/dev/stderr
            error=true
        fi
    done

    if [[ "$error" == true ]]; then
        exit 1
    else
        exit 0
    fi
fi


template_dir="$(dirname "$(readlink -f "$0")")/templates"
json_file="$template_dir/patch.json"
gitignore_file="$template_dir/gitignore"
spec_file="$template_dir/patch.spec"
license_file="$template_dir/COPYING"
config_file="$template_dir/CONFIG"
icon_file="$template_dir/icon-openrepos.png"

get_single_config() { # 1: config file, 2: key, 3: default value
    # we can safely assume the file exists and is valid
    # which means we can also assume the key exists if it is required

    local line="$(grep "^$2:" "$1" | head -1)"

    if [[ -z "$line" ]]; then
        echo "$3"
        return
    fi

    local key="${line%%:*}"
    local value="$(trim "${line#$key:}")"

    if [[ -z "$value" ]]; then
        echo -n "$3"
    else
        echo -n "$value"
    fi
}

get_multi_config() { # 1: config file, 2: key, 3: default value
    # we can safely assume the file exists and is valid
    # which means we can also assume the key exists if it is required

    local key_at="$(grep -nr "^$2:" "$1" | cut -d':' -f1)"
    local lines=()
    readarray -t lines <<<"$(tail --lines=+"$((key_at+1))" "$1")"
    local selected=()

    for l in "${lines[@]}"; do
        local first="${l:0:1}"

        case "$first" in
            -) selected+=("$(trim "${l:1}")");;
            "#") echo -n;;  # ignore comments
            *)  if [[ "$l" == *":"* ]]; then
                    break # is next key; done
                else
                    echo -n # ignore as comment
                fi
            ;;
        esac
    done

    if (( ${#selected[@]} == 0 )); then
        echo -n "$3"
    else
        printf "%s\n" "${selected[@]}"
    fi
}

require_templates() {
    if [[ ! -d "$template_dir" ]]; then
        echo "error: template directory not found" >/dev/stderr
        return 1
    fi

    for i in "$json_file" "$gitignore_file" "$spec_file" "$license_file" "$config_file" "$icon_file"; do
        if [[ ! -f "$i" ]]; then
            echo "error: template '$i' not found" >/dev/stderr
            return 1
        fi
    done

    return 0
}

config_checker="$0"
require_config() { # 1: expected config file location
    local config="$1"
    if [[ ! -f "$config" ]]; then
        echo "error: could not find config file" >/dev/stderr
        return 1
    else
        "$config_checker" --check-config "$config"

        if (( $? != 0 )); then
            echo "error: config file contains errors" >/dev/stderr
            echo "       please check the output above and try again" >/dev/stderr
            return 1
        fi
    fi

    return 0
}

# return unchecked base config path to be used
# in validator functions
__get_config_path() {
    if [[ -f "$(pwd)/build/CONFIG" ]]; then
        echo "warning: config file in non-standard location found (below 'build')" >/dev/stderr
    fi

    echo -n "$(pwd)/CONFIG"
}

# return unchecked base build path to be used in
# validator functions
__get_build_path() {
    echo -n "$(pwd)/build"
}

# return path of latest package build
# assumes build path and config have been checked before
__get_package_path() { # 1: type (rpm/tarball)
    if [[ "$1" != "rpm" && "$1" != "tarball" ]]; then
        echo "internal error: invalid package type requested" >/dev/stderr
        return 1
    fi

    local extension=""
    if [[ "$1" == rpm ]]; then
        extension="rpm"
    else
        extension="tar.gz"
    fi

    package_name="$(get_single_config "$(__get_config_path)" "PackageName")"
    package="$(find "$(__get_build_path)" -maxdepth 1 -iname "$package_name-*.$extension" | sort --version-sort | tail -1)"
    echo -n "$package"
}

# return default original files path
__get_original_path() {
    echo -n "$(pwd)/original"
}

# return default patched files path
__get_patched_path() {
    echo -n "$(pwd)/patched"
}

# return default source package path
__get_sources_path() {
    echo -n "$(pwd)/source-packages"
}

# return default extras path
__get_extra_path() {
    echo -n "$(pwd)/extra"
}

require_build_config() {
    # require build dir
    local build_dir="$(__get_build_path)"
    if [[ ! -d "$build_dir" ]]; then
        echo "error: could not find build directory" >/dev/stderr
        return 1
    fi

    # require valid config
    local config="$(__get_config_path)"
    require_config "$config" || return 1

    return 0
}

require_current_package() { # 1: type (rpm/tarball)
    require_build_config || return 1
    local config="$(__get_config_path)"
    local build_dir="$(__get_build_path)"

    # find package file
    local package="$(__get_package_path "$1")"

    if [[ -z "$package" ]]; then
        echo "error: no $1 found" >/dev/stderr
        return 1
    fi

    return 0
}

# create diff and save it to $2
# assumes config is valid
__create_diff() { # 1: config, 2: save path
    local prefix="$(get_single_config "$1" "Prefix" "/")"

    if [[ "$prefix" != "/" && "$prefix" != *"/" ]]; then
        prefix="$prefix/"
    fi

    local original="$(__get_original_path)"
    local patched="$(__get_patched_path)"

    git diff --no-index --src-prefix="a${prefix}" --dst-prefix="b${prefix}" -- "$original" "$patched" |\
        sed -Ee "s@(--git|---|\+\+\+) (a|b)${prefix}(${original#/}|${patched#/})/@\1 \2${prefix}@g;
                    s@(--git a/.*) b${prefix}${patched#/}/@\1 b${prefix}@g" > "$2"
}


if [[ "$create_new" == true ]]; then
    require_templates || exit 1

    if [[ -e "$create_new_name" ]]; then
        echo "error: the file or directory with the name '$create_new_name' already exists" >/dev/stderr
        exit 1
    fi

    mkdir -p "$create_new_name"
    cd "$create_new_name"

    git init
    git checkout -b master

    mkdir -p "$(__get_extra_path)"
    mkdir -p "$(__get_original_path)"
    mkdir -p "$(__get_patched_path)"
    mkdir -p "$(__get_sources_path)"
    mkdir -p "$(__get_build_path)"

    cp "$config_file" CONFIG
    cp "$license_file" COPYING
    cp "$gitignore_file" .gitignore

    git add CONFIG COPYING .gitignore
    git commit -m "patch skeleton automatically created by sailfish-patch"

    echo "patch created: $create_new_name"

    cat <<EOF
== SailfishOS Patch: $create_new_name ==

The patch has been prepared. The next step is to edit the
configuration file (CONFIG). Then copy all original files into the two
directories '$(basename "$(__get_original_path)")' and '$(basename "$(__get_patched_path)")'. Make your changes in the latter.

You can add all packages the patch is based on in the 'SourcePackages' field
in the configuration file. Running 'sailfish-patch -u' will update all source
files and makes it easy to adapt the patch to new upstream versions.

Note that it must be possible for sailfish-patch to connect to your device via
SSH if you want to use source packages from the official repos. Make sure this
is configured correctly. (This is not needed for OpenRepos sources.)

If you want to add your own settings pages or include translation files,
icons etc. in your patch, you can place them in the '$(basename "$(__get_extra_path)")' directory. Note
that this is not yet supported for RPMs.
EOF

    exit 0
else
    __update_is_valid_version() { # 1: comparison (>, <, >=, <=, =); 2,3: versions to compare
        local comparison="$1"
        local check_1="$2"
        local check_2="$3"

        get_largest() {
            printf '%s\n' "$@" | sort --version-sort | head -1
        }

        get_smallest() {
            printf '%s\n' "$@" | sort --version-sort | tail -1
        }

        ok=false
        case "$comparison" in
            ">") if [[ "$(get_largest "$check_1" "$check_2")" != "$check_1" ]]; then
                    ok=true
                fi
            ;;
            ">=") if [[ "$check_1" == "$check_2" || "$(get_largest "$check_1" "$check_2")" != "$check_1" ]]; then
                    ok=true
                fi
            ;;
            "<") if [[ "$(get_smallest "$check_1" "$check_2")" != "$check_1" ]]; then
                    ok=true
                fi
            ;;
            "<=") if [[ "$check_1" == "$check_2" || "$(get_smallest "$check_1" "$check_2")" != "$check_1" ]]; then
                    ok=true
                fi
            ;;
            "=") if [[ "$check_1" == "$check_2" ]]; then
                    ok=true
                fi
            ;;
        esac

        if [[ "$ok" == false ]]; then
            return 1
        else
            return 0
        fi
    }

    # we assume config has been checked before and is valid
    __update_fetch_latest_sources() {
        local original="$(__get_original_path)"
        local config="$(__get_config_path)"
        local packages="$(__get_sources_path)"
        local extract="${packages%/}/extract"
        local base="$(pwd)"
        local -r openrepos_url="https://sailfish.openrepos.net/"

        if ! rm -rf "$original"; then
            echo "error: failed to remove old original sources" >/dev/stderr
            return 1
        fi

        if [[ -d "$packages" ]]; then
            rm -rf "$packages" || return 1
        fi

        if [[ -d "$extract" ]]; then
            rm -rf "$extract" || return 1
        fi

        if ! mkdir -p "$extract"; then
            echo "error: failed to prepare temporary files" >/dev/stderr
            return 1
        fi

        if ! mkdir -p "$packages"; then
            echo "error: failed to prepare temporary files" >/dev/stderr
            return 1
        fi

        local sources=()
        readarray -t sources <<<"$(get_multi_config "$config" "SourcePackages")"

        if (( ${#sources[@]} == 0 )); then
            # nothing to fetch
            return 0
        fi

        for s in "${sources[@]}"; do
            local source="$(trim "${s%% *}")"
            local version=
            local version_action=
            local file="$packages/${source}.rpm"

            if echo "$s" | grep -Pqoe " ([><]=?|=) "; then
                version_action="$(echo "$s" | grep -Poe "([><]=?|=)")"
                version="${s##* }"
            fi

            if [[ "$source" == *":"* ]]; then
                # assume openrepos
                local user="${source%%:*}"
                local source="${source#*:}"
                file="$packages/${source}.rpm"

                if [[ -z "$user" ]]; then
                    echo "error: failed to determine OpenRepos user for '$source'" >/dev/stderr
                    return 1
                fi

                local repo_url="${openrepos_url%/}/${user}/personal/main/${source:0:1}/"
                if ! local html="$(curl "$repo_url")"; then
                    echo "error: failed to download OpenRepos repository for '$source'" >/dev/stderr
                    return 1
                fi

                set -o pipefail
                local repo="$(echo "$html" | hxnormalize -x -e | hxselect html body a -s "\n" |\
                    sed -E 's/^<a href=".*?\.rpm">//g;s#</a>##g' |\
                    grep "armv7hl" |\
                    sort --version-sort -u)"

                if (( $? != 0 )); then
                    echo "error: failed to extract OpenRepos repository listing for '$source'" >/dev/stderr
                    return 1
                fi

                local rpm="$(echo "$repo" | grep "$source" | tail -1)"

                if (( $? != 0 )); then
                    echo "error: failed to extract OpenRepos package url for '$source'" >/dev/stderr
                    return 1
                fi
                set +o pipefail

                cd "$packages"
                if ! curl "${repo_url%/}/$rpm" -o "${source}.rpm"; then
                    echo "error: failed to download package '$source'" >/dev/stderr
                    cd "$base"
                    return 1
                fi
                cd "$base"
            else
                # assume Jolla store
                if [[ -z "$SF_PATCH_SSH_TARGET" ]]; then
                    echo "error: ssh target not set" >/dev/stderr
                    echo "       cannot fetch packages from official repos without ssh access to the device" >/dev/stderr
                    return 1
                fi

                remote_temp_dir="/tmp/sailfish-patch.tmp"
                ssh "$SF_PATCH_SSH_TARGET" "rm -rf '$remote_temp_dir';\
                                            mkdir -p '$remote_temp_dir' &&\
                                            pkcon download '$remote_temp_dir' '$source'"

                if (( $? != 0 )); then
                    echo "error: failed to download package '$source' from official repos via ssh" >/dev/stderr
                    return 1
                fi

                scp nemo@"$SF_PATCH_SSH_TARGET":"$remote_temp_dir/${source}*" "$file"

                if (( $? != 0 )); then
                    echo "error: failed transfer downloaded package '$source' from the device" >/dev/stderr
                    return 1
                fi
            fi

            if [[ -n "$version" && -n "$version_action" ]]; then
                if ! __update_is_valid_version "$version_action" "$(rpm -qp --queryformat '%{VERSION}' "$file" 2>/dev/null)" "$version"; then
                    echo "error: could not fetch appropriate version of '$source' ($version$version_action$(rpm -qp --queryformat '%{VERSION}' "$file"))" >/dev/stderr
                    return 1
                fi
            fi

            cd "$extract"

            if ! rpm2cpio "$file" | cpio -idmv; then
                echo "error: failed to extract '$file'" >/dev/stderr
                cd "$base"
                return 1
            fi
            cd "$base"
        done

        cd "$extract"

        prefix="$(get_single_config "$config" "Prefix" "/")"

        if [[ ! -d ".$prefix" ]]; then
            echo "error: invalid prefix $prefix" >/dev/stderr
            cd "$base"
            return 1
        fi

        cd ".$prefix"
        shopt -s nullglob dotglob
        mkdir -p "$original"
        mv -t "$original" * || return 1
        shopt -u nullglob dotglob

        cd "$base"
        return 0
    }

    __update_copy_sources() {
        local original="$(__get_original_path)"
        local patched="$(__get_patched_path)"

        if ! rm -rf "$patched"; then
            echo "error: failed to remove old patched sources" >/dev/stderr
            return 1
        fi

        if [[ ! -d "$original" ]]; then
            echo "error: failed to copy sources - files not found" >/dev/stderr
            return 1
        fi

        cp -r "$original" "$patched" || return 1
        return 0
    }

    # we assume config has been checked before and is valid
    __update_apply_diff() { # 1: diff file
        local original="$(__get_original_path)"
        local patched="$(__get_patched_path)"
        local prefix="$(get_single_config "$(__get_config_path)" "Prefix" "/")"
        local tmp_diff="$(mktemp -p . update_diff_XXXX.patch)"

        if ! cp -r "$original" "$original.tmp"; then
            echo "error: failed to create temporary copy of pre-patched original files" >/dev/stderr
            return 1
        fi

        if [[ "$prefix" != "/" && "$prefix" != *"/" ]]; then
            prefix="$prefix/"
        fi

        sed "$1" -Ee "s@(--git|---|\+\+\+) a${prefix}@\1 a${original}/@g;
                   s@(--git|---|\+\+\+) b${prefix}@\1 b${patched}/@g;
                   s@(--git a/.*) b${prefix}@\1 b${patched}/@g" > "$tmp_diff" || return 1

        strip="$(pwd)"
        strip="${strip%/}/"
        strip="$(echo "$strip" | grep -oe "/" | wc -l)"

        if [[ "$patch_utility" == "git" ]]; then
            if ! git apply --reject --binary -p "$strip" -v "$tmp_diff"; then
                echo "error: failed to apply diff" >/dev/stderr
                return 1
            fi
        elif [[ "$patch_utility" == "patch" ]]; then
            if ! patch -p"$strip" -u <"$tmp_diff"; then
                echo "error: failed to apply diff" >/dev/stderr
                return 1
            fi
        else
            echo "internal error: unknown patch utility '$patch_utility'" >/dev/stderr
            return 1
        fi

        if [[ ! -d "$original.tmp" ]]; then
            echo "error: could not find temporary copy of original files" >/dev/stderr
            return 1
        fi

        if ! rm -rf "$original"; then
            echo "error: failed to remove stale original sources" >/dev/stderr
            return 1
        fi

        mv "$original.tmp" "$original"
        rm "$tmp_diff"
    }

    if [[ "$import" == true ]]; then
        if git rev-parse --git-dir 2>/dev/null; then
            echo "error: already inside a Git repository;" >/dev/stderr
            echo "       sailfish-patch heavily relies on having only one" >/dev/stderr
            echo "       patch per repo" >/dev/stderr
            exit 1
        fi

        require_config "$import_config" || exit 1

        package="$(get_single_config "$import_config" "PackageName")"
        "$import_command" --create "$package" || exit 1

        cd "$package"
        cp "$import_config" "$(__get_config_path)"

        __update_fetch_latest_sources || exit 1
        __update_copy_sources || exit 1

        # extract tarball
        base="$(pwd)"
        extract_dir="$(mktemp -d tmp.XXXX -p .)"
        cd "$extract_dir"
        tar -xzvf "$import_tarball"

        if [[ ! -f "unified_diff.patch" ]]; then
            echo "error: could not find diff file in tarball" >/dev/stderr
            exit 1
        fi

        cd "$base"

        __update_apply_diff "$extract_dir/unified_diff.patch" || exit 1

        rm -rf "$extract_dir"

        git add "$(__get_config_path)" "$(__get_original_path)" "$(__get_patched_path)" &&\
            git commit -m "patch automatically imported by sailfish-patch"
    fi

    if [[ "$update" == true ]]; then
        original="$(__get_original_path)"
        patched="$(__get_patched_path)"

        if [[ -n "$(git status --porcelain)" ]]; then
            if [[ "$force" == true ]]; then
                echo "warning: there are uncommitted changes"
            else
                echo "error: there are uncommitted changes" >/dev/stderr
                exit 1
            fi
        fi

        require_config "$(__get_config_path)" || exit 1

        readarray -t sources <<<"$(get_multi_config "$(__get_config_path)" "SourcePackages")"

        if (( ${#sources[@]} == 0 )); then
            if [[ -d "$original" && -n "$(shopt -s nullglob; shopt -s dotglob; echo "$original"/* )" ]]; then
                echo "warning: no source packages specified but original source files found"
            else
                mkdir -p "$original"
            fi

            echo "no source packages specified: automatic update is not possible"
        else
            if [[ ! -d "$original" || ! -d "$patched" ]]; then
                echo "error: make sure the following directories exists:" >/dev/stderr
                echo "- $original" >/dev/stderr
                echo "- $patched" >/dev/stderr
                exit 1
            fi

            have_original=true
            if [[ -z "$(shopt -s nullglob; shopt -s dotglob; echo "$original"/* )" ]]; then
                echo "warning: there are no original files"
                have_original=false
            fi

            have_patched=true
            if [[ -z "$(shopt -s nullglob; shopt -s dotglob; echo "$patched"/* )" ]]; then
                echo "warning: there are no patched files"
                have_patched=false
            fi

            original_updated=false
            if [[ "$have_original" == false ]]; then
                __update_fetch_latest_sources || exit 1
                original_updated=true
            fi

            patched_updated=false
            if [[ "$have_patched" == false ]]; then
                __update_copy_sources || exit 1
                patched_updated=true
            fi

            diff_out="$(mktemp -p . original_diff_XXXX.patch)"
            __create_diff "$(__get_config_path)" "$diff_out"

            if [[ "$original_updated" == false ]]; then
                __update_fetch_latest_sources || exit 1
            fi

            if [[ "$patched_updated" == false ]]; then
                __update_copy_sources || exit 1
            fi

            __update_apply_diff "$diff_out" || exit 1
            rm "$diff_out"
        fi
    fi

    if [[ "$build" == true ]]; then
        original="$(__get_original_path)"
        patched="$(__get_patched_path)"

        # require original files
        if [[ ! -d "$original" ]]; then
            echo "error: missing original files directory" >/dev/stderr
            echo "note:  even if the patch only adds files, the 'original'" >/dev/stderr
            echo "       directory has to be present" >/dev/stderr
            exit 1
        fi

        if [[ ! -d "$patched" ]]; then
            echo "error: missing patched files directory" >/dev/stderr
            exit 1
        fi

        # require valid config and build directory
        require_build_config || exit 1
        base="$(pwd)"
        config="$(__get_config_path)"
        build_dir="$(__get_build_path)"
        extra_dir="$(__get_extra_path)"

        # require templates
        require_templates || exit 1

        # create temp dir
        temp_build_dir="$(mktemp -d -p "$build_dir" build.XXXX)"

        # create diff
        __create_diff "$config" "${temp_build_dir}/unified_diff.patch"
        cd "$temp_build_dir"

        # import extra files
        if [[ -d "$extra_dir" ]]; then
            if (( $(find "$extra_dir" -mindepth 1 -type d | wc -l) > 0 )); then
                echo "warning: subdirectories are not allowed for extra files"
                echo "         all files will be copied in the same directory"
            fi

            if find "$extra_dir" -type f | grep -Pq --invert-match -e ".*\.(qml|js|png|svg|qm)"; then
                echo "warning: unsupported extra files found"
                echo "         only files with the following extensions are allowed:"
                echo "            .qml, .js, .png, .svg, .qm"
                echo "         all other files will be ignored!"
            fi

            if (( $(find "$extra_dir" -type f -iregex ".*\.\(qml\|js\|png\|svg\|qm\)" | wc -l) > 0 )); then
                mkdir -p "$temp_build_dir/extra"
                find "$extra_dir" -type f -iregex ".*\.\(qml\|js\|png\|svg\|qm\)" -exec cp {} "$temp_build_dir/extra" \;
            else
                echo "warning: directory for extra files found but there are no usable files"
            fi
        fi

        # prepare files and templates
        rpm_build_dir="$temp_build_dir/rpm_build"
        tarball_build_dir="$temp_build_dir/tarball_build"
        dist_build_dir="$temp_build_dir/dist_build"

        mkdir -p "$rpm_build_dir" "$tarball_build_dir" "$dist_build_dir"

        cp "$spec_file" rpm.spec
        cp "$json_file" "$rpm_build_dir/patch.json"

        if [[ -d extra && -n "$(shopt -s nullglob; shopt -s dotglob; echo extra/* )" ]]; then
            cp extra/* "$rpm_build_dir"
            mv extra/* "$tarball_build_dir"
        fi

        cp unified_diff.patch "$rpm_build_dir/unified_diff.patch"
        cp unified_diff.patch "$dist_build_dir/unified_diff.patch"
        mv unified_diff.patch "$tarball_build_dir/unified_diff.patch"

        if [[ -f "$base/COPYING" ]]; then
            cp "$base/COPYING" "$dist_build_dir"
        fi

        cp "$config" "$dist_build_dir"
        readarray -t screenshots <<<"$(get_multi_config "$config" "Screenshots")"

        for s in "${screenshots[@]}"; do
            if [[ -f "$s" || -f "$(dirname "$config")/$s" ]]; then
                [[ -f "$s" ]] && cp "$s" "$dist_build_dir" || cp "$(dirname "$config")/$s" "$dist_build_dir"
                s="${s//\//\\/}" # escape slashes
                sed -E -i "s/-[ \t]*$s$/- $(basename "$s")/g" "$dist_build_dir/$(basename "$config")"
            fi
        done

        rpm_version="$(get_single_config "$config" "Version")"
        release="$(get_single_config "$config" "Release")"
        package="$(get_single_config "$config" "PackageName")"
        echo "building version: $rpm_version-$release"

        # configure spec and json files
        for i in PackageName Summary Version Release Maintainer DisplayName Category; do
            value="$(get_single_config "$config" "$i")"
            [[ -z "$value" ]] && continue

            value="${value//\//\\/}" # escape slashes
            sed -i "s/@${i^^}@/$value/g" rpm.spec
            sed -i "s/@${i^^}@/$value/g" "$rpm_build_dir/patch.json"
        done

        # configure json-specific fields
        description="$(get_multi_config "$config" "Description")"
        description="${description//\"/\\\\\"}" # escape quotes
        description="${description//&/\\\\&}" # escape ampersand
        awk -v r="$description" '{gsub(/@DESCRIPTION@/,r)}1'\
            "$rpm_build_dir/patch.json" > _tmp && mv _tmp "$rpm_build_dir/patch.json"

        # configure rpm-specific fields
        for i in Requires Obsoletes Conflicts; do
            values="$(get_multi_config "$config" "$i")"

            if [[ -n "$values" ]]; then
                readarray -t m_lines <<<"$(echo "$values")"

                for l in "${m_lines[@]}"; do
                    l="${l//\//\\/}" # escape slashes
                    sed -i "$(echo -en "/@${i^^}@/i\\\\\n$i: $l")" rpm.spec
                done
            fi

            sed -i "s/@${i^^}@//g" rpm.spec
        done

        # build rpm
        echo "building RPM..."
        rpmbuild -bb --build-in-place rpm.spec --define "_rpmdir $(pwd)/RPMS"

        if (( $? != 0 )); then
            echo "error: failed to build RPM" >/dev/stderr
        else
            mv --backup=t RPMS/**/*.rpm "$build_dir"
            echo "success: RPM built"
        fi

        # build tarball
        echo "building tarball..."
        cd "$tarball_build_dir"
        tarball="$package-$rpm_version-$release.tar.gz"
        tar -czvf "$tarball" *

        if (( $? != 0 )); then
            echo "error: failed to build tarball" >/dev/stderr
        else
            echo "success: tarball built"
            mv --backup=t "$tarball" "$build_dir"
        fi

        # build code distribution package
        echo "building code distribution package..."
        mv "$dist_build_dir" "$package" &&\
            mv --backup=t "$package" "$build_dir"

        if (( $? != 0 )); then
            echo "error: failed to build code distribution package" >/dev/stderr
        else
            echo "success: code distribution package built"
        fi

        # clean up
        rm -r "$temp_build_dir"
        cd "$base"
    fi

    if [[ "$publish_via_ssh" == true ]]; then
        echo "deploying patch..."
        require_current_package rpm || exit 1
        rpm="$(__get_package_path rpm)"

        if [[ ! -f "$SF_PATCH_PASSFILE" ]]; then
            echo "error: passphrase file not found" >/dev/stderr
            exit 2
        fi

        config="$(__get_config_path)" # we assume it has been checked before
        package_name="$(get_single_config "$config" "PackageName")"

        scp "$rpm" nemo@"$SF_PATCH_SSH_TARGET":"$SF_PATCH_REMOTE_PATH"
        head -1 "$SF_PATCH_PASSFILE" | ssh "$SF_PATCH_SSH_TARGET" "devel-su pkcon -y install-local '$SF_PATCH_REMOTE_PATH/$(basename "$rpm")'"
        head -1 "$SF_PATCH_PASSFILE" | ssh "$SF_PATCH_SSH_TARGET" "devel-su /usr/sbin/patchmanager -a '$package_name'"

        echo "patch deployed"
    fi

    __wizard_load() { # 1: type, 2: title, 3: key
        config="$(__get_config_path)" # we assume it has been checked before

        if [[ "${1:0:1}" == "s" ]]; then
            value="$(get_single_config "$config" "$3")"
        else
            value="$(get_multi_config "$config" "$3")"
        fi

        echo -n "$value" | xclip -selection c

        if [[ "${1:0:1}" == "s" ]]; then
            read -n 1 -s -p "$2: $value"; echo
        else
            read -n 1 -s -p "$2:
$value"
            echo
        fi

    }

    __wizard_load_screenshots() {
        config="$(__get_config_path)" # we assume it has been checked before
        first_path="$(get_multi_config "$config" "Screenshots" | head -1)"
        if [[ "${first_path:0:1}" == "/" ]]; then
            screenshots_path="$(readlink -m "$(dirname "$first_path")")"
        elif [[ -n "$first_path" ]]; then
            # relative paths are relative to the config file
            screenshots_path="$(readlink -m "$(dirname "$(__get_config_path)")")"
        else
            screenshots_path=
        fi
        echo -n "$screenshots_path" | xclip -selection c
        read -n 1 -s -p "Screenshots (first directory path): $screenshots_path"; echo
    }

    if [[ "$publish_to_openrepos" == true ]]; then
        echo "running wizard for publishing to OpenRepos..."
        echo "Each value will be copied to the clipboard. Press any key to load the"
        echo "next value."
        echo
        require_current_package rpm || exit 1
        rpm="$(__get_package_path rpm)"
        config="$(__get_config_path)" # safe because we already checked above

        name="$(get_single_config "$config" "DisplayName")"
        echo -n "Patch: $name" | xclip -selection c
        read -n 1 -s -p "Application name: Patch: $name"; echo

        echo -n "Applications -> Patches" | xclip -selection c
        read -n 1 -s -p "Category: Applications -> Patches"; echo

        readarray -t keywords <<<"$(get_multi_config "$config" "Keywords")"
        for i in "${keywords[@]}"; do
            echo -n "$i" | xclip -selection c
            read -n 1 -s -p "Keyword: $i"; echo
        done

        echo -n "$icon_file" | xclip -selection c
        read -n 1 -s -p "Icon: $icon_file"; echo

        __wizard_load s "Summary" "Summary"
        __wizard_load m "Description" "Description"
        __wizard_load_screenshots

        echo -n "$rpm" | xclip -selection c
        read -n 1 -s -p "Application version: $rpm"; echo

        __wizard_load m "Changelog" "Changelog"
    fi

    if [[ "$publish_to_pm_catalogue" == true ]]; then
        echo "running wizard for publishing to Patchmanager's online catalogue..."
        echo "Each value will be copied to the clipboard. Press any key to load the"
        echo "next value."
        echo
        require_current_package tarball || exit 1
        tarball="$(__get_package_path tarball)"

        __wizard_load s "Internal name" "PackageName"
        __wizard_load s "Display name" "DisplayName"
        __wizard_load m "Description" "Description"
        __wizard_load s "Category" "Category"
        __wizard_load s "Discussion link" "DiscussionLink"
        __wizard_load s "Donations link" "DonationsLink"
        __wizard_load s "Sources link" "SourcesLink"
        __wizard_load_screenshots
        __wizard_load s "Version" "Version"
        __wizard_load m "Compatible versions" "CompatibleVersions"
        echo -n "$tarball" | xclip -selection c
        read -n 1 -s -p "Patch archive: $tarball"; echo

        __wizard_load m "Changelog" "Changelog"

        echo done
    fi
fi
