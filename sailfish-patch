#!/bin/bash
# kate: syntax bash
#
# sailfish-patch 2.0.0 (2019-06-29)
# Copyright (C) 2016  Cornerman (https://github.com/cornerman/sailfish-patch)
#               2018-2019  Mirian Margiani
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#

DEPENDENCIES=(git sed scp ssh rpmbuild xclip tar)

# check environment variables
publish_via_ssh_possible=true
if [[ -z "$SF_PATCH_PASSFILE" ]]; then
    publish_via_ssh_possible=false
fi

if [[ -z "$SF_PATCH_SSH_TARGET" ]]; then
    publish_via_ssh_possible=false
fi

if [[ -z "$SF_PATCH_REMOTE_PATH" ]]; then
    SF_PATCH_REMOTE_PATH="/home/nemo"
fi


trap "exit 2" TERM
export TOP_PID=$$

abort() {
    pkill -P $TOP_PID
    kill -s TERM $TOP_PID
}

dependencies() { # 1: echo/no-echo
    ret=0
    print=
    if [[ "$1" == "echo" ]]; then
        print=true
        echo -e "\nDependencies:"
    fi

    for i in "${DEPENDENCIES[@]}"; do
        if which "$i" 2> /dev/null >&2; then
            if [[ -n "$print" ]]; then
                echo "    - $i: $(which "$i")"
            fi
        else
            if [[ -n "$print" ]]; then
                echo "    - $i: missing"
                ret=1
            else
                return 1
            fi
        fi
    done

    return "$ret"
}

version() {
    echo "\
sailfish-patch 2.0.0 (2019-06-29)
Copyright (C) 2016  Cornerman
              2018-2019  Mirian Margiani
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law."
    dependencies echo
}

if ! dependencies no-echo; then
    version
    echo -e "\nerror: missing dependencies" >/dev/stderr
    exit 255
fi

show_help() {
script="$(basename "$0")"
    echo "\
** sailfish-patch **

Manage your SailfishOS patches.

Create a new patch skeleton with '-c NAME' and put the original files
in the new Git branch 'original'. Copy everything to the branch 'master' and
make your changes. Configure the project in 'build/CONFIG'. Build with '-b'.

Note: separate settings pages are currently only supported via Patchmanager.

Usage:
    $script -c NAME
    $script [-b] [-p] [-Po] [-Pm]
    $script -C FILE
    $script [-h] [-V]

Arguments:
    -c, --create NAME           - create new patch skeleton in NAME
    -C, --check-config FILE     - validate config file FILE
    -b, --build                 - build RPM and tarball
    -p, --publish-ssh           - publish and install patch on your device via ssh
    -Po, --publish-openrepos    - wizard for publishing in OpenRepos
    -Pm, --publish-patchmanager - wizard for publishing in PM's online catalogue
    -V, --version               - show version and license information
    -h, --help                  - show this help and exit

Environment:
    - path to a local file containing your devel-su passphrase
        SF_PATCH_PASSFILE=$SF_PATCH_PASSFILE
    - how to connect to your device via ssh (config name or IP)
        SF_PATCH_SSH_TARGET=$SF_PATCH_SSH_TARGET
    - path to a directory where patch RPMs will be stored on your device
        SF_PATCH_REMOTE_PATH=$SF_PATCH_REMOTE_PATH
"
}

check_config=false
check_config_name=
create_new=false
create_new_name=
build=false
publish_via_ssh=false
publish_to_openrepos=false
publish_to_pm_catalogue=false

while [[ $# > 0 ]]; do
    case "$1" in
        --help|-h) show_help; exit 0;;
        --version|-V) version; exit 0;;
        -C|--check-config)
            check_config=true
            shift

            if [[ -z "$1" ]]; then
                echo "error: no config file name given" >/dev/stderr
                exit 2
            else
                check_config_name="$1"
            fi
        ;;
        -c|--create)
            create_new=true
            shift

            if [[ -z "$1" ]]; then
                echo "error: no name for the new patch directory given" >/dev/stderr
                exit 1
            else
                create_new_name="$1"
            fi
        ;;
        -b|--build) build=true;;
        -p|--publish-ssh)
            if [[ "$publish_via_ssh_possible" == false ]]; then
                echo "error: environment not set up correctly for publishing via ssh" >/dev/stderr
                exit 1
            else
                publish_via_ssh=true
            fi
        ;;
        -Po|--publish-openrepos) publish_to_openrepos=true;;
        -Pm|--publish-patchmanager) publish_to_pm_catalogue=true;;
        -*) echo "unknown option: $1";;
        *) shift; continue;;
    esac
    shift
done

categories="Homescreen
Browser
Camera
Calendar
Clock
Contacts
Email
Gallery
Media
Messages
Phone
Silica
Settings
Keyboard
Others"

versions="1.1.9.30
2.0.2.51
2.0.4.14
2.0.5.6
2.1.0.11
2.1.1.12
2.1.1.23
2.1.1.24
2.1.1.26
2.1.2.3
2.1.3.3
2.1.3.5
2.1.3.7
2.1.4.13
2.1.4.14
2.1.4.15
2.2.0.29
2.2.1.18
2.2.1.19
3.0.0.5
3.0.0.8
3.0.0.11
3.0.1.11
3.0.1.14
3.0.2.8
3.0.3.8
3.0.3.9
3.0.3.10"

trim() {
    local var="$*"
    var="${var#"${var%%[![:space:]]*}"}"
    var="${var%"${var##*[![:space:]]}"}"
    echo -n "$var"
}

if [[ "$check_config" == true ]]; then
    if [[ ! -f "$check_config_name" ]]; then
        echo "error: could not find configuration file!" >/dev/stderr
        exit 2
    fi

    # check keys and references, files, screenshots
    error=false
    count=0
    keys_found=()

    is_multiline=
    is_multiline_at=0
    is_multiline_required=false
    lines_for_multi=0

    while IFS='' read -r line || [[ -n "$line" ]]; do
        count="$((count+1))"
        line="$(trim "$line")"
        key="${line%%:*}"
        value="$(trim "${line#$key:}")"

        if [[ -z "$line" ]]; then
            continue
        elif [[ "$line" == "#"* ]]; then
            continue
        fi

        if [[ -n "$is_multiline" ]] && [[ "$line" == "-"* ]]; then
            lines_for_multi="$((lines_for_multi+1))"
            value="$(trim "${value#-}")"

            if [[ "$is_multiline" == "Screenshots" ]]; then
                if [[ ! -f "$value" ]] && [[ ! -f "$(dirname "$check_config_name")/$value" ]]; then
                    echo "error: screenshot file '$value' not found (line $count)" >/dev/stderr
                    error=true
                fi
            elif [[ "$is_multiline" == "CompatibleVersions" ]]; then
                if ! echo "$versions" | grep -Pqoe "^$value"; then
                    echo "error: invalid version '$value' (line $count)" >/dev/stderr
                    error=true
                fi
            fi

            continue
        fi

        if [[ "$line" != *":"* ]]; then
            echo "warning: comment lines should start with '#' (line $count)"
            continue
        fi

        if [[ -n "$is_multiline" ]]; then
            if (( lines_for_multi == 0 )); then
                echo "warning: empty multi-line field '$is_multiline' at line $is_multiline_at"

                if [[ "$is_multiline_required" == true ]]; then
                    echo "error: required field '$key' is empty" >/dev/stderr
                    error=true
                fi
            fi

            is_multiline=
            is_multiline_at=0
            lines_for_multi=0
            is_multiline_required=false
        fi

        # single line
        is_single=true
        case "$key" in
            Prefix|DiscussionLink|DonationsLink|SourcesLink)
                # may be empty
                if [[ -z "$value" ]]; then
                    echo "note: no value given for '$key'"
                fi
            ;;
            DisplayName|Maintainer|Summary)
                # must not be empty
                if [[ -z "$value" ]]; then
                    echo "error: required field '$key' is empty" >/dev/stderr
                    error=true
                fi
            ;;
            PackageName)
                # must not be empty
                if [[ -z "$value" ]]; then
                    echo "error: required field '$key' is empty" >/dev/stderr
                    error=true
                fi
                # needs special rules
                if echo "$value" | grep -Pqoe "[^a-zA-Z0-9-_]"; then
                    echo "error: package name contains invalid characters (line $count)" >/dev/stderr
                    echo "       allowed are: a-z, A-Z, 0-9, -, _ (no spaces)"
                    error=true
                elif echo "$value" | grep -Pqoe "^[-_]"; then
                    echo "error: package name must not start with '-' or '_' (line $count)" >/dev/stderr
                    error=true
                fi
            ;;
            Category)
                # must not be empty
                if [[ -z "$value" ]]; then
                    echo "error: required field '$key' is empty" >/dev/stderr
                    error=true
                fi
                # needs special rules
                if ! echo "$categories" | grep -Pqoe "^$value"; then
                    echo "error: invalid category '$value' on line $count" >/dev/stderr
                    error=true
                fi
            ;;
            Version)
                # must not be empty
                if [[ -z "$value" ]]; then
                    echo "error: required field '$key' is empty" >/dev/stderr
                    error=true
                fi
                # needs special rules
                if ! echo "$value" | grep -Pqoe '^[0-9]+\.[0-9]+\.[0-9]+'; then
                    echo "error: version number must consist of three numbers separated by dots (X.Y.Z; line $count)" >/dev/stderr
                    error=true
                fi
            ;;
            Release)
                # must not be empty
                if [[ -z "$value" ]]; then
                    echo "error: required field '$key' is empty" >/dev/stderr
                    error=true
                fi
                # needs special rules
                if ! echo "$value" | grep -Pqoe '^[1-9][0-9]*'; then
                    echo "error: release number must be exactly one number without leading zeros (XYZ; line $count)" >/dev/stderr
                    error=true
                fi
            ;;
            *) is_single=false;;
        esac

        # multi line
        if [[ "$is_single" == false ]]; then
            case "$key" in
                Screenshots|Changelog|Requires|Keywords)
                    # regular fields
                    is_multiline="$key"
                    is_multiline_at="$count"
                ;;
                Description|CompatibleVersions)
                    # required fields
                    is_multiline="$key"
                    is_multiline_at="$count"
                    is_multiline_required=true
                ;;
                *)  echo "error: invalid key '$key' on line $count" >/dev/stderr
                    error=true
                ;;
            esac
        fi

        if printf "%s\n" "${keys_found[@]}" | grep -Pqoe "^$key"; then
            echo "error: field '$key' is defined more than once (line $count)" >/dev/stderr
            error=true
        else
            keys_found+=("$key")
        fi
    done < "$check_config_name"

    # check for required fields
    for r in DisplayName PackageName Category Maintainer Summary Version Release Description CompatibleVersions; do
        if ! printf "%s\n" "${keys_found[@]}"  | grep -Pqoe "^$r"; then
            echo "error: required field '$r' is missing" >/dev/stderr
            error=true
        fi
    done

    if [[ "$error" == true ]]; then
        exit 1
    else
        exit 0
    fi
fi


template_dir="$(dirname "$(readlink -f "$0")")/templates"
json_file="$template_dir/patch.json"
gitignore_file="$template_dir/gitignore"
spec_file="$template_dir/patch.spec"
license_file="$template_dir/COPYING"
config_file="$template_dir/CONFIG"
icon_file="$template_dir/icon-openrepos.png"

get_single_config() { # 1: config file, 2: key, 3: default value
    # we can safely assume the file exists and is valid
    # which means we can also assume the key exists if it is required

    line="$(grep "^$2:" "$1" | head -1)"

    if [[ -z "$line" ]]; then
        echo "$3"
        return
    fi

    key="${line%%:*}"
    value="$(trim "${line#$key:}")"

    if [[ -z "$value" ]]; then
        echo -n "$3"
    else
        echo -n "$value"
    fi
}

get_multi_config() { # 1: config file, 2: key, 3: default value
    # we can safely assume the file exists and is valid
    # which means we can also assume the key exists if it is required

    key_at="$(grep -nr "^$2:" "$1" | cut -d':' -f1)"
    readarray -t lines <<<"$(tail --lines=+"$((key_at+1))" "$1")"
    selected=()

    for l in "${lines[@]}"; do
        first="${l:0:1}"

        case "$first" in
            -) selected+=("$(trim "${l:1}")");;
            "#") echo -n;;  # ignore comments
            *)  if [[ "$l" == *":"* ]]; then
                    break # is next key; done
                else
                    echo -n # ignore as comment
                fi
            ;;
        esac
    done

    if (( ${#selected[@]} == 0 )); then
        echo -n "$3"
    else
        printf "%s\n" "${selected[@]}"
    fi
}

require_templates() {
    if [[ ! -d "$template_dir" ]]; then
        echo "error: template directory not found!" >/dev/stderr
        abort
    fi

    for i in "$json_file" "$gitignore_file" "$spec_file" "$license_file" "$config_file" "$icon_file"; do
        if [[ ! -f "$i" ]]; then
            echo "error: template '$i' not found" >/dev/stderr
            abort
        fi
    done
}

config_checker="$0"
require_config() { # 1: expected config file location
    local config="$1"
    if [[ ! -f "$config" ]]; then
        echo "error: could not find config file" >/dev/stderr
        abort
    else
        "$config_checker" --check-config "$config"

        if (( $? != 0 )); then
            echo "error: config file contains errors" >/dev/stderr
            echo "       please check the output above and try again" >/dev/stderr
            abort
        fi
    fi
}

# return unchecked base config path to be used
# in validator functions
__get_config_path() {
    echo -n "$(pwd)/build/CONFIG"
}

require_build_config() {
    # require build dir
    local build_dir="$(dirname "$(__get_config_path)")"
    if [[ ! -d "$build_dir" ]]; then
        echo "error: could not find build directory" >/dev/stderr
        abort
    fi

    # require valid config
    local config="$(__get_config_path)"
    require_config "$config"

    # return valid config path
    # MUST be directly below 'build'
    echo -n "$config"
}

require_current_package() { # 1: type (rpm/tarball)
    if [[ "$1" != "rpm" && "$1" != "tarball" ]]; then
        echo "internal error: invalid package type requested" >/dev/stderr
        abort
    fi

    local extension=""
    if [[ "$1" == rpm ]]; then
        extension="rpm"
    else
        extension="tar.gz"
    fi

    local config="$(require_build_config)"
    local build_dir="$(dirname "$config")"

    # find package file
    package_name="$(get_single_config "$(__get_config_path)" "PackageName")"
    package="$(find "$build_dir" -maxdepth 1 -iname "$package_name-*.$extension" | sort --version-sort | tail -1)"

    if [[ -z "$package" ]]; then
        echo "error: no $1 found" >/dev/stderr
        abort
    fi

    # return valid package path
    echo -n "$package"
}


if [[ "$create_new" == true ]]; then
    require_templates

    if [[ -e "$create_new_name" ]]; then
        echo "error: the file or directory with the name '$create_new_name' already exists" >/dev/stderr
        exit 1
    fi

    mkdir -p "$create_new_name"
    cd "$create_new_name"

    git init
    git checkout -b original

    cat <<EOF > "README"
SailfishOS Patch
================

Place your original files in the branch 'original' and commit them.

Make sure there are ONLY the original files that you want to base the diff
on are in this branch!

Then, change to the branch 'master' and make your changes. The diff will
include all differences between the two branches 'original' and 'master'
EXCEPT for the two directories 'build' and 'extra'.

Below 'build' you will find a sample configuration file named CONFIG which
you have to adapt to configure your patch. (It is documented in-place.)

If you want to add your own settings pages or include translation files,
icons etc. in your patch, you can place them in the 'extra' directory. Note
that this is not yet supported for RPMs.

EOF

    git add README
    git commit -m "patch skeleton automatically created by sailfish-patch"

    git checkout -b master

    mkdir -p extra
    mkdir -p build
    cd build

    cp "$config_file" CONFIG
    cp "$license_file" COPYING
    cp "$gitignore_file" .gitignore

    git add CONFIG COPYING .gitignore
    git commit -m "build templates automatically imported by sailfish-patch"

    echo "patch created: $create_new_name"
    exit 0
else
    if [[ "$build" == true ]]; then
        # require git root
        if [[ ! -d .git ]]; then
            echo "error: not in the root directory of a Git repository" >/dev/stderr
            exit 2
        fi

        orig_branch="$(git branch --list | grep -E '^\s*original$')"

        if [[ -z "$orig_branch" ]]; then
            echo "error: missing 'original' branch!" >/dev/stderr
            echo "       Create this branch and commit the original QML files without any changes." >/dev/stderr
            echo "       The diff is created based on this branch." >/dev/stderr
            exit 2
        fi

        # require valid config and build directory
        base="$(pwd)"
        config="$(require_build_config)"
        build_dir="$(dirname "$config")"

        # require templates
        require_templates

        # create temp dir
        temp_build_dir="$(mktemp -d -p "$build_dir" build.XXXX)"

        # create diff
        prefix_dir="$(get_single_config "$config" "Prefix" "/")"

        if [[ "$prefix_dir" != "/" && "$prefix_dir" != *"/" ]]; then
            prefix_dir="$prefix_dir/"
        fi

        git diff original --src-prefix="a$prefix_dir" --dst-prefix="b$prefix_dir" -- . ':(exclude)build/*' > "$temp_build_dir/unified_diff.patch"
        cd "$temp_build_dir"

        # copy extra files
        extra_dir="$base/extra"
        if [[ -d "$extra_dir" ]]; then
            mkdir extra
            find "$extra_dir" -type f -iregex ".*\.\(qml|js|png|svg|qm\)" -exec cp {} "$temp_build_dir/extra" \;
        fi

        # copy and configure templates
        rpm_build_dir="$temp_build_dir/rpm_build"
        cp "$spec_file" rpm.spec
        mkdir -p "$rpm_build_dir"
        [[ -d extra ]] && cp extra/* "$rpm_build_dir"
        cp unified_diff.patch "$rpm_build_dir/unified_diff.patch"
        cp "$json_file" "$rpm_build_dir/patch.json"

        tarball_build_dir="$temp_build_dir/tarball_build"
        mkdir -p "$tarball_build_dir"
        mv unified_diff.patch "$tarball_build_dir/unified_diff.patch"
        [[ -d extra ]] && mv extra/* "$tarball_build_dir"

        rpm_version="$(get_single_config "$config" "Version")"
        release="$(get_single_config "$config" "Release")"
        package="$(get_single_config "$config" "PackageName")"
        echo "building version: $rpm_version-$release"

        # configure spec and json files
        for i in PackageName Summary Version Release Maintainer DisplayName Category; do
            value="$(get_single_config "$config" "$i")"
            [[ -z "$value" ]] && continue

            value="${value//\//\\/}" # escape slashes
            sed -i "s/@${i^^}@/$value/g" rpm.spec
            sed -i "s/@${i^^}@/$value/g" "$rpm_build_dir/patch.json"
        done

        description="$(get_multi_config "$config" "Description")"
        sed -i "s/@DESCRIPTION@/$description/g" "$rpm_build_dir/patch.json"

        requires="$(get_multi_config "$config" "Requires")"
        if [[ -n "$requires" ]]; then
            readarray -t req_lines <<<"$(echo "$requires")"
            for r in "${req_lines[@]}"; do
                sed -i "/@REQUIRES@/i\
Requires: $r" rpm.spec
            done
        fi
        sed -i "s/@REQUIRES@//g" rpm.spec

        # build rpm
        echo "building RPM..."
        rpmbuild -bb --build-in-place rpm.spec --define "_rpmdir $(pwd)/RPMS"

        if (( $? != 0 )); then
            echo "error: failed to build RPM" >/dev/stderr
        else
            mv --backup=t RPMS/**/*.rpm "$build_dir"
            echo "success: RPM built"
        fi

        # build tarball
        echo "building tarball..."
        cd "$tarball_build_dir"
        tarball="$package-$rpm_version-$release.tar.gz"
        tar -czvf "$tarball" *

        if (( $? != 0 )); then
            echo "error: failed to build tarball" >/dev/stderr
        else
            echo "success: tarball built"
            mv --backup=t "$tarball" "$build_dir"
        fi

        rm -r "$temp_build_dir"
        cd "$base"
    fi

    if [[ "$publish_via_ssh" == true ]]; then
        echo "deploying patch..."
        rpm="$(require_current_package rpm)"

        if [[ ! -f "$SF_PATCH_PASSFILE" ]]; then
            echo "error: passphrase file not found!" >/dev/stderr
            exit 2
        fi

        config="$(__get_config_path)" # we assume it has been checked before
        package_name="$(get_single_config "$config" "PackageName")"

        scp "$rpm" nemo@"$SF_PATCH_SSH_TARGET":"$SF_PATCH_REMOTE_PATH"
        head -1 "$SF_PATCH_PASSFILE" | ssh "$SF_PATCH_SSH_TARGET" "devel-su pkcon -y install-local '$SF_PATCH_REMOTE_PATH/$(basename "$rpm")'"
        head -1 "$SF_PATCH_PASSFILE" | ssh "$SF_PATCH_SSH_TARGET" "devel-su /usr/sbin/patchmanager -a '$package_name'"

        echo "patch deployed"
    fi

    __wizard_load() { # 1: type, 2: title, 3: key
        config="$(__get_config_path)" # we assume it has been checked before

        if [[ "${1:0:1}" == "s" ]]; then
            value="$(get_single_config "$config" "$3")"
        else
            value="$(get_multi_config "$config" "$3")"
        fi

        echo -n "$value" | xclip -selection c

        if [[ "${1:0:1}" == "s" ]]; then
            read -n 1 -s -p "$2: $value"; echo
        else
            read -n 1 -s -p "$2:
$value"
            echo
        fi

    }

    __wizard_load_screenshots() {
        config="$(__get_config_path)" # we assume it has been checked before
        first_path="$(get_multi_config "$config" "Screenshots" | head -1)"
        if [[ "${first_path:0:1}" == "/" ]]; then
            screenshots_path="$(readlink -m "$(dirname "$first_path")")"
        elif [[ -n "$first_path" ]]; then
            screenshots_path="$(readlink -m "$(dirname "$config")")"
        else
            screenshots_path=
        fi
        echo -n "$screenshots_path" | xclip -selection c
        read -n 1 -s -p "Screenshots (first directory path): $screenshots_path"; echo
    }

    if [[ "$publish_to_openrepos" == true ]]; then
        echo "running wizard for publishing to OpenRepos..."
        echo "Each value will be copied to the clipboard. Press any key to load the"
        echo "next value."
        echo
        rpm="$(require_current_package rpm)"
        config="$(__get_config_path)" # safe because we already checked above

        name="$(get_single_config "$config" "DisplayName")"
        echo -n "Patch: $name" | xclip -selection c
        read -n 1 -s -p "Application name: Patch: $name"; echo

        echo -n "Applications -> Patches" | xclip -selection c
        read -n 1 -s -p "Category: Applications -> Patches"; echo

        readarray -t keywords <<<"$(get_multi_config "$config" "Keywords")"
        for i in "${keywords[@]}"; do
            echo -n "$i" | xclip -selection c
            read -n 1 -s -p "Keyword: $i"; echo
        done

        echo -n "$icon_file" | xclip -selection c
        read -n 1 -s -p "Icon: $icon_file"; echo

        __wizard_load s "Summary" "Summary"
        __wizard_load m "Description" "Description"
        __wizard_load_screenshots

        echo -n "$rpm" | xclip -selection c
        read -n 1 -s -p "Application version: $rpm"; echo

        __wizard_load m "Changelog" "Changelog"
    fi

    if [[ "$publish_to_pm_catalogue" == true ]]; then
        echo "running wizard for publishing to Patchmanager's online catalogue..."
        echo "Each value will be copied to the clipboard. Press any key to load the"
        echo "next value."
        echo
        tarball="$(require_current_package tarball)"

        __wizard_load s "Internal name" "PackageName"
        __wizard_load s "Display name" "DisplayName"
        __wizard_load m "Description" "Description"
        __wizard_load s "Category" "Category"
        __wizard_load s "Discussion link" "DiscussionLink"
        __wizard_load s "Donations link" "DonationsLink"
        __wizard_load s "Sources link" "SourcesLink"
        __wizard_load_screenshots
        __wizard_load s "Version" "Version"
        __wizard_load m "Compatible versions" "CompatibleVersions"
        echo -n "$tarball" | xclip -selection c
        read -n 1 -s -p "Patch archive: $tarball"; echo

        __wizard_load m "Changelog" "Changelog"

        echo done
    fi
fi
