#!/bin/bash
# kate: syntax bash; remove-trailing-spaces all;
#-
# sailfish-patch 2.7.0 (2023-04-17)
# SPDX-FileCopyrightText: 2018-2023 Mirian Margiani
# SPDX-License-Identifier: GPL-3.0-or-later
#
# This is free software: you are free to change and redistribute it.
# There is NO WARRANTY, to the extent permitted by law.
# Full license text: https://gnu.org/licenses/gpl.html
#
# Originally based on gen-sailfish-patch by Cornerman (2016):
# https://github.com/cornerman/gen-sailfish-patch
#·

DEPENDENCIES=(
    patch git scp ssh sed xclip mktemp
    rpm rpmbuild rpm2cpio cpio tar
    hxselect hxnormalize
    du numfmt html2text
    pngcrush pngquant convert
)

# check environment variables
publish_via_ssh_possible=true
if [[ -z "$SF_PATCH_PASSFILE" ]]; then
    publish_via_ssh_possible=false
fi


if [[ -z "$SF_PATCH_SSH_TARGET" ]]; then
    publish_via_ssh_possible=false
elif [[ "$SF_PATCH_SSH_TARGET" == *@* ]]; then
    tmp_SF_PATCH_REMOTE_USERNAME="${SF_PATCH_SSH_TARGET%%@*}"
    SF_PATCH_SSH_TARGET="${SF_PATCH_SSH_TARGET#*@}"  # remove the user name
fi

if [[ -z "$SF_PATCH_REMOTE_USERNAME" ]]; then
    SF_PATCH_REMOTE_USERNAME="${tmp_SF_PATCH_REMOTE_USERNAME:-nemo}"
elif [[ -n "$tmp_SF_PATCH_REMOTE_USERNAME" ]]; then
    if [[ "$tmp_SF_PATCH_REMOTE_USERNAME" != "$SF_PATCH_REMOTE_USERNAME" ]]; then
        echo "warning: different user names for SSH and deployments are not supported" >&2
        echo "         (all commands will use SF_PATCH_REMOTE_USERNAME='$SF_PATCH_REMOTE_USERNAME')"
    fi
fi

if [[ -z "$SF_PATCH_REMOTE_PATH" ]]; then
    SF_PATCH_REMOTE_PATH="/home/$SF_PATCH_REMOTE_USERNAME"
fi

if [[ -z "$SF_PATCH_GLOBAL_DEFAULTS" ]]; then
    SF_PATCH_GLOBAL_DEFAULTS="$HOME/.config/sailfish-patch.conf"
fi

if [[ -z "$SF_PATCH_LICENSE_CACHE" ]]; then
    SF_PATCH_LICENSE_CACHE="$HOME/.cache/sailfish-patch/licenses"
    mkdir -p "$SF_PATCH_LICENSE_CACHE" || true
fi

dependencies() { # 1: echo/no-echo
    local ret=0
    local print=
    if [[ "$1" == "echo" ]]; then
        print=true
        echo -e "\nDependencies:"
    fi

    for i in "${DEPENDENCIES[@]}"; do
        if which "$i" 2> /dev/null >&2; then
            if [[ -n "$print" ]]; then
                echo "    - $i: $(which "$i")"
            fi
        else
            if [[ -n "$print" ]]; then
                printf -- "    - \e[0m\e[1m%s: missing\e[0m\n" "$i"
                ret=1
            else
                return 1
            fi
        fi
    done

    return "$ret"
}

function version() {
    sed -n '/^#-/,/^#·/p;/^#·/q' "$0" | sed '1d;$s/.*//;s/#[ ]*//g;' |\
        sed 's/SPDX-FileCopyrightText:/Copyright:/g;s/SPDX-License-Identifier:/License:/g;'
    dependencies echo
}

if ! dependencies no-echo; then
    version
    echo -e "\nerror: missing dependencies" >&2
    exit 255
fi

cDEFAULT_CONFIG_NAME=CONFIG
cDEFAULT_LICENSE_NAME=COPYING
cDEFAULT_GITIGNORE_NAME=.gitignore
cDEFAULT_ICON_NAME=sailfish-patch_icon.png
cDEFAULT_JSON_NAME=patch.json
cDEFAULT_SPEC_NAME=rpm.spec
cDEFAULT_QMLDETAILS_NAME=PatchDetails.qml

cSCRIPT="$(basename "$0")"
show_help() {
local script="$cSCRIPT"
    echo "\
** sailfish-patch **

Manage your SailfishOS patches.

Create a new patch skeleton with '-c NAME' and put the original files
in the directory 'original'. Copy everything to the directory 'patched' and
make your changes. Configure the project in '$cDEFAULT_CONFIG_NAME'. Build with '-b'.

Note: separate settings pages are currently only supported via Patchmanager.

Usage:
    $script -c NAME
    $script -u [RPMS]
    $script [-b] [-p] [-Po [latest]] [-Pm [latest]]

    $script -i CONFIG SOURCE [RPMS]
    $script [-C|-Cu] FILE
    $script [-S|-S ROUNDS]

    $script [-h] [-V]

Arguments:
    -c, --create NAME           - create new patch skeleton in NAME
    -b, --build                 - build RPM and tarball
    -u, --update [RPMS]         - update the working directory with the latest sources, or
                                  import the patch if only a config file and a patch file
                                  called 'unified_diff.patch' are found.
                                  This needs a working SSH connection for downloading from official
                                  sources, i.e. packages not from OpenRepos. Optionally set
                                  'RPMS' to use already downloaded package files from the
                                  given directory.
    -p, --publish-ssh           - publish and install patch on your device via ssh
    -Po, --publish-openrepos    - wizard for publishing in OpenRepos
                                  When given 'latest' as argument to -Po, the wizard
                                  will provide info for updating the entry.
    -Pm, --publish-patchmanager - wizard for publishing in PM's online catalogue
                                  See -Po for more details.

    -C, --check-config FILE     - validate config file FILE
    -Cu, --config-update FILE   - same as -C, but update sections automatically
                                  (e.g. add new releases to the CompatibleVersions section)
    -S, --optimize-screenshots [ROUNDS] - optimize PNG screenshot files of the current project
                                  optional: specify number of processing
                                  rounds for best result (default: 1)
    -i, --import CONFIG SOURCE [RPMS] - setup a new working directory for the given patch
                                  This command is especially useful for importing patches that
                                  were not created with this tool. In other cases, -u might be
                                  more suited for the task.
                                  SOURCE can either be a tarball containing the patch file
                                  (unified_diff.patch) in its root, or it can be a patch/diff.
                                  Optionally set 'RPMS' to use already downloaded package
                                  files from the given directory.
                                  Note: use -eC to create a new config file.
    -I, --inspect               - only with --build: do not actually build anything to allow
                                  inspecting configured build sources (RPM spec, diff, etc.)
    -Id, --inspect-diff DIFF    - list changed files in a patch file, e.g. unified_diff.patch,
                                  and find source packages if an SSH connection is available
    -f, --force                 - skip some safety checks

    -V, --version               - show version and license information
    -h, --help                  - show this help and exit

Templates:
    -eC, --export-config        - export $cDEFAULT_CONFIG_NAME template
    -eL, --export-license       - download/import license text to $cDEFAULT_LICENSE_NAME
    -eG, --export-gitignore     - export $cDEFAULT_GITIGNORE_NAME template
    -eI, --export-icon          - export OpenRepos icon template
    -eJ, --export-json          - export $cDEFAULT_JSON_NAME template
    -eS, --export-spec          - export rpm specfile template
    -eQ, --export-qmldetails    - export $cDEFAULT_QMLDETAILS_NAME template

Debug/Development Options:
    -R, --check-releases        - load a list of SailfishOS releases from the Internet
                                  and compare it to the list of versions currently supported
                                  by this script
    -g, --use-git-apply         - use git-apply(1) instead of patch(1) for applying
                                  the patch (see -i and -u)

Environment:
    - path to a local file containing your devel-su passphrase
        SF_PATCH_PASSFILE=$SF_PATCH_PASSFILE
    - how to connect to your device via ssh (config name or IP)
        SF_PATCH_SSH_TARGET=$SF_PATCH_SSH_TARGET
    - user name to use for deploying and for ssh connections
        SF_PATCH_REMOTE_USERNAME=$SF_PATCH_REMOTE_USERNAME
    - path to a directory where patch RPMs will be stored on your device
        SF_PATCH_REMOTE_PATH=$SF_PATCH_REMOTE_PATH
    - path to the global configuration file
        SF_PATCH_GLOBAL_DEFAULTS=$SF_PATCH_GLOBAL_DEFAULTS
    - path to a directory where downloaded license texts are cached
        SF_PATCH_LICENSE_CACHE=$SF_PATCH_LICENSE_CACHE
"
}

check_config=false
check_config_name=
check_update_config=false
create_new=false
create_new_name=
build=false
build_inspect=false
update=false
update_local_sources=""
import=false
import_config=
import_source=
import_command="$0"
import_inspect=false
import_inspect_file=""
optimize_screenshots=false
optimize_screenshots_runs=1
publish_via_ssh=false
publish_to_openrepos=false
publish_to_pm_catalogue=false
publish_update_only=false
list_releases=false
force=false
patch_utility="patch"
debug_export_template=()

while (( $# > 0 )); do
    case "$1" in
        --help|-h) show_help; exit 0;;
        --version|-V) version; exit 0;;
        -C|--check-config)
            check_config=true
            shift

            if [[ -z "$1" ]]; then
                { [[ -f "$cDEFAULT_CONFIG_NAME" ]] && check_config_name="$cDEFAULT_CONFIG_NAME"; } || {
                    echo "error: no config file name given" >&2
                    exit 2
                }
            else
                check_config_name="$1"
            fi
        ;;
        -Cu|--config-update)
            check_config=true
            check_update_config=true
            shift

            if [[ -z "$1" ]]; then
                { [[ -f "$cDEFAULT_CONFIG_NAME" ]] && check_config_name="$cDEFAULT_CONFIG_NAME"; } || {
                    echo "error: no config file name given" >&2
                    exit 2
                }
            else
                check_config_name="$1"
            fi
        ;;
        -f|--force) force=true;;
        -c|--create)
            create_new=true
            shift

            if [[ -z "$1" ]]; then
                echo "error: no name for the new patch directory given" >&2
                exit 1
            else
                create_new_name="$1"
            fi
        ;;
        -b|--build) build=true;;
        -I|--inspect) build_inspect=true;;
        -Id|--inspect-diff)
            import_inspect=true
            shift

            if [[ ! -f "$1" ]]; then
                printf -- "%s\n" "error: could not find patch file '$1'" >&2
                exit 1
            elif [[ "$(file --mime-type -b "$1")" != "text/x-diff" ]]; then
                printf -- "%s\n" "error: '$1' is not a patch file" >&2
                exit 1
            fi

            import_inspect_file="$1"
        ;;
        -u|--update)
            update=true

            if [[ -d "$2" ]]; then
                update_local_sources="$(readlink -m "$(dirname "$2")")/$(basename "$2")"
                printf -- "%s\n" "loading source packages locally from '$update_local_sources'" >&2
                shift
            fi
        ;;
        -i|--import)
            import=true
            shift

            if [[ -z "$1" ]]; then
                echo "error: no config file for the import given" >&2
                exit 1
            elif [[ ! -f "$1" ]]; then
                echo "error: config file to be imported not found" >&2
                exit 1
            else
                # save absolute path
                import_config="$(readlink -m "$(dirname "$1")")/$(basename "$1")"
            fi

            shift
            if [[ -z "$1" ]]; then
                echo "error: no tarball for the import given" >&2
                exit 1
            elif [[ ! -f "$1" ]]; then
                echo "error: tarball to be imported not found" >&2
                exit 1
            else
                # save absolute path
                import_source="$(readlink -m "$(dirname "$1")")/$(basename "$1")"
            fi

            if [[ -d "$2" ]]; then
                update_local_sources="$(readlink -m "$(dirname "$2")")/$(basename "$2")"
                printf -- "%s\n" "loading source packages from '$update_local_sources'" >&2
                shift
            fi
        ;;
        -p|--publish-ssh)
            if [[ "$publish_via_ssh_possible" == false ]]; then
                echo "error: environment not set up correctly for publishing via ssh" >&2
                exit 1
            else
                publish_via_ssh=true
            fi
        ;;
        -Po|--publish-openrepos)
            publish_to_openrepos=true
            [[ "$2" == latest ]] && publish_update_only=true && shift
        ;;
        -Pm|--publish-patchmanager)
            publish_to_pm_catalogue=true
            [[ "$2" == latest ]] && publish_update_only=true && shift
        ;;
        -S|--optimize-screenshots)
            optimize_screenshots=true

            if [[ -n "$2" ]] && echo -n "$2" | grep -Pqoe '^\d+$'; then
                optimize_screenshots_runs="$2"
                shift
            fi
        ;;
        -R|--check-releases) list_releases=true;;
        -g|--use-git-apply) patch_utility=git;;
        -eC|--export-config   ) debug_export_template+=(config);;
        -eL|--export-license  ) debug_export_template+=(license);;
        -eG|--export-gitignore) debug_export_template+=(gitignore);;
        -eI|--export-icon     ) debug_export_template+=(icon);;
        -eJ|--export-json     ) debug_export_template+=(json);;
        -eS|--export-spec     ) debug_export_template+=(spec);;
        -eQ|--export-qmldetails  ) debug_export_template+=(qmldetails);;
        -*) echo "unknown option: $1";;
        *) shift; continue;;
    esac
    shift
done

check_categories="Homescreen
Browser
Camera
Calendar
Clock
Contacts
Email
Gallery
Media
Messages
Phone
Silica
Settings
Keyboard
Others"

# a list of all Sailfish versions supported by patchmanager
# (taken from: https://coderus.openrepos.net/pm2/upload/)
# note: this list differs from the one at https://coderus.openrepos.net/whitesoft/sailversion
check_versions="1.1.9.30
2.0.2.51
2.0.4.14
2.0.5.6
2.1.0.11
2.1.1.12
2.1.1.23
2.1.1.24
2.1.1.26
2.1.2.3
2.1.3.3
2.1.3.5
2.1.3.7
2.1.4.13
2.1.4.14
2.1.4.15
2.2.0.29
2.2.1.18
2.2.1.19
3.0.0.5
3.0.0.8
3.0.0.11
3.0.1.11
3.0.1.14
3.0.2.8
3.0.3.8
3.0.3.9
3.0.3.10
3.1.0.11
3.2.0.12
3.2.1.20
3.3.0.14
3.3.0.16
3.4.0.22
3.4.0.24
4.0.1.45
4.0.1.48
4.1.0.23
4.1.0.24
4.2.0.19
4.2.0.21
4.3.0.12
4.3.0.15
4.4.0.58
4.4.0.64
4.4.0.68
4.4.0.72
4.5.0.16
4.5.0.18
4.5.0.19"

declare -A check_default_dummies=(
[SourcePackages]="username:source-package-from-openrepos <= 1.0.10|source-package-from-official-repo"
[Prefix]=""
[DisplayName]="Pretty Name"
[PackageName]="sfos-patch-category-name"
[Category]=""
[Keywords]=""
[Maintainer]="username"
[Summary]="short summary for package managers"
[Description]="long description for the store|possibly spanning over multiple lines"
[DiscussionLink]="https://example.org/discussion"
[DonationsLink]="https://example.org/donations"
[SourcesLink]="https://example.org/sources"
[Version]=""
[Release]=""
[License]=""
[Requires]="another-required-package"
[Conflicts]="my-conflicting-package = 0.0.1"
[Obsoletes]="an-old-name < x.y.z|replaced-package < x.y.z"
[Screenshots]=""
[CompatibleVersions]=""
[Changelog]=""
[TestCommands]=""
)

declare -A default_config_values=(
[SourcePackages]="m@dummy"
[Prefix]="s@/usr/share"
[DisplayName]="s@dummy"
[PackageName]="s@dummy"
[Category]="s@Others"
[Keywords]="m@Patch"
[Maintainer]="s@dummy"
[Summary]="s@dummy"
[Description]="m@dummy"
[DiscussionLink]="s@dummy"
[DonationsLink]="s@dummy"
[SourcesLink]="s@dummy"
[Version]="s@0.1.0"
[Release]="s@1"
[License]="s@GPL-3.0-or-later"
[Requires]="m@dummy"
[Conflicts]="m@dummy"
[Obsoletes]="m@dummy"
[Screenshots]="m@screenshot-1.png|/home/user/screen-2.png|path/relative/to/config/file/location/screen-3.png"
[CompatibleVersions]="m@$(echo -n "$check_versions" | sort -V | tr '\n' '|' | sed 's/|$//')"
[Changelog]="m@1.0.0 ($(date +%F)):|- initial public release"
[TestCommands]="m@dummy"
)

required_config_values="
DisplayName
PackageName
Category
Maintainer
Summary
Version
Release
License
Description
CompatibleVersions"

check_allowed_in_global_config="Prefix
Maintainer
DiscussionLink
DonationsLink
SourcesLink
Version
Release
License"

trim() {
    local var="$*"
    var="${var#"${var%%[![:space:]]*}"}"
    var="${var%"${var##*[![:space:]]}"}"
    echo -n "$var"
}

select_range() { # 1: from pattern, 2: to pattern
    # Print lines between $1 and $2, excluding both lines matching $1 and $2.
    [[ -z "$1" ]] && return 1; local from_pattern="$1"
    [[ -z "$2" ]] && return 1; local to_pattern="$2"
    awk "/$from_pattern/{flag=1;next}/$to_pattern/{flag=0}flag"
}

require_global_config() {
    if [[ -z "$SF_PATCH_GLOBAL_DEFAULTS" ]]; then
        echo "internal error: \$SF_PATCH_GLOBAL_DEFAULTS is empty" >&2
        return 1
    fi

    mkdir -p "$(dirname "$SF_PATCH_GLOBAL_DEFAULTS")"

    if [[ ! -f "$SF_PATCH_GLOBAL_DEFAULTS" ]]; then
        cat <<EOF > "$SF_PATCH_GLOBAL_DEFAULTS"
# Default configuration values for sailfish-patch
#
# The values configured here will be used as default values in new
# configuration files generated by sailfish-patch. They have no effect for already
# existing files.
#
# Only the following (single-line) fields can be configured here:
$(echo -n "$check_allowed_in_global_config" | tr '\n' ' ' | sed 's/^/# /g;s/ $//;')
#
# Lines starting with '#' will be ignored.
# Entry lines are key-value pairs joined by ':' (one entry per line).

# Version: 1.0.0
# Release: 1
# License: GPL-3.0-or-later

# Prefix: /usr/share
# Maintainer: Foo Bar
# DiscussionLink: https://discuss.example.org/foobar
# DonationsLink: https://donate.example.org/foobar
# SourcesLink: https://sources.example.org/foobar

# [keep this line: sailfish-patch 2.7.0 (2023-04-17)]
# kate: syntax SailfishOS Patch
EOF
    fi
}

# return the default configuration value for field $1
# The function takes globally configured defaults into account and returns,
# if available, the global value or else the dummy value.
__get_default_config() { # 1: field/key
    require_global_config || exit 1
    [[ -z "$1" ]] && return 1

    if echo -n "$check_allowed_in_global_config" | grep -Pqoe "^$1$" && grep -Pqoe "^$1:" "$SF_PATCH_GLOBAL_DEFAULTS"; then
        value="$(grep -Pe "^$1:" "$SF_PATCH_GLOBAL_DEFAULTS" | cut -d ':' -f2-)"
        value="$(trim "$value")"
        echo "$value"
    elif [[ -n "${default_config_values[$1]}" ]]; then
        value="${default_config_values[$1]}"
        type="${value%%@*}"

        if [[ "$value" == [ms]"@dummy" ]]; then
            value="${check_default_dummies[$1]}"
        else
            value="${value#*@}"
        fi

        if [[ "$type" == m ]]; then
            echo "$value" | sed 's/^/- /;s/|/\n- /g'
        else
            echo "$value"
        fi
    else
        echo "error: default value for invalid key requested ($1)" >&2
        return 1
    fi
}

__save_template_licenses() { # 1: output file
    # SPDX license list v3.20 (2023-04-16), encoded and compressed using:
    # curl https://spdx.org/licenses/licenses.json | grep '"licenseId":'| grep -Poe ': ".*?",$' | tr -d ': ",' | sort | xz | base64
    cat <<EOF | base64 -d | xz -d > "$1"
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
EOF
}

__save_template_copying() { # 1: output file, 2: SPDX id
    local ident; ident="$(trim "$2")"
    local output="$1"
    local cached="$SF_PATCH_LICENSE_CACHE/$ident"

    if [[ -n "$ident" ]] && ! __save_template_licenses /dev/stdout | grep -Fxqoe "$ident"; then
        # not a SPDX id, cannot save anything
        return 1
    fi

    if [[ -f "$cached" ]]; then
        cp "$cached" "$output"
    else
        read -n 1 -s -p "download license text for $ident? (y/N)> "
        if [[ "$REPLY" == "y" ]]; then
            local url="https://raw.githubusercontent.com/spdx/license-list-data/main/text/$ident.txt"
            curl "$url" | tee "$output" > "$cached" || {
                printf -- "%s\n" "failed to fetch license text for $ident from $url" >&2
            }
        else
            printf -- "%s\n" "no license text available for $ident" >&2
        fi
    fi
}

if [[ "$list_releases" == true ]]; then
    # a list of all Sailfish versions supported by patchmanager
    # (taken from: https://coderus.openrepos.net/pm2/upload/)
    # note: this list differs from the one at https://coderus.openrepos.net/whitesoft/sailversion

    which "curl" 2> /dev/null >&2 && _have_curl=true
    which "column" 2> /dev/null >&2 && _have_column=true

    if [[ "$_have_curl" != true ]]; then
        echo "error: 'curl' is not available, cannot retrieve list of all SailfishOS releases" >&2
        error=true
    else
        if ! _all_releases="$(curl -sS https://coderus.openrepos.net/whitesoft/sailversion)"; then
            echo "error: failed to load the list of all releases from https://coderus.openrepos.net/whitesoft/sailversion" >&2
            error=true
        else
            _head_line="Script?;Version;Codename;Date"
             _sep_line="-------;-------;--------;----"

            if [[ "$_have_column" == true ]]; then
                # print formatted
                join -t';' -a 1 -a 2 -j 1 -o 1.2,2.1,2.2,2.3 \
                    <(echo "$check_versions" | sed 's/$/;  yes/g' | sort) <(echo "$_all_releases" | sed 's/ - /;/g' | sort) |\
                        sed "1 s/^/$_head_line\n$_sep_line\n/; $ s/$/\n$_sep_line\n$_head_line/" |\
                        sed 's/^;/ ;/g' | column -s ';' -t
            else
                # print unformatted
                echo "note: install 'column' to get formatted output" >&2
                join -t',' -a 1 -a 2 -j 1 -o 1.2,2.1,2.2,2.3 \
                    <(echo "$check_versions" | sed 's/$/,yes/g' | sort) <(cho "$_all_releases" | sed 's/ - /,/g' | sort)  |\
                        sed "1 s/^/$_head_line\n/;"
            fi

            echo "
This script only supports SailfishOS releases supported by Patchmanager.
If a version is not marked with 'yes' in the listing above, make sure it is
supported by cross-checking https://coderus.openrepos.net/pm2/upload/. Then
add it to the list of supported versions by updating variable '\$check_versions'
and create a pull request at https://github.com/ichthyosaurus/sailfish-patch."
        fi
    fi

    if [[ "$error" == true ]]; then
        echo -e "\nReleases supported by this script:"
        echo      "----------------------------------"
        echo "$check_versions"
        exit 1
    fi

    exit 0
fi


if [[ "$check_config" == true ]]; then
    if [[ ! -f "$check_config_name" ]]; then
        echo "error: could not find configuration file" >&2
        exit 2
    fi

    # check keys and references, files, screenshots
    __check_dummy_value() { # 1: key, 2: value to check, 3: line
        local key="$1"
        local value="$2"
        local line="$3"

        if [[ -z "$value" ]]; then
            return 0
        fi

        if echo "$value" | grep -Pqoe "@[^ ]+@"; then
            echo "error: field '$key' is not configured ($value; line $line)" >&2
            return 1
        fi

        if [[ -z "${check_default_dummies[$key]}" ]]; then
            return 0
        elif echo "${check_default_dummies[$key]}" | sed 's/|/\n/g' |\
                grep -Pqoe "^$(echo "$value" | sed 's/[][\.|$(){}?+*^]/\\&/g')"; then
            echo "error: field '$key' still contains a dummy value (line $line)" >&2
            return 1
        else
            return 0
        fi
    }

    error=false
    count=0
    keys_found=()

    is_multiline=
    is_multiline_at=0
    is_multiline_required=false
    lines_for_multi=0

    while IFS='' read -r line || [[ -n "$line" ]]; do
        count="$((count+1))"
        line="$(trim "$line")"
        key="${line%%:*}"
        value="$(trim "${line#$key:}")"

        orig_line="$line"
        orig_value="$value"

        if [[ -z "$line" ]]; then
            continue
        elif [[ "$line" == "#"* ]]; then
            continue
        fi

        if [[ -n "$is_multiline" ]] && [[ "$line" == "-"* ]]; then
            lines_for_multi="$((lines_for_multi+1))"
            value="$(trim "${value#-}")"

            # BEGIN value checks for multi line fields
            __check_package_specification() { # 1: error name

                if [[ "$is_multiline" == "Obsoletes" ]]; then
                    if ! echo "$value" | grep -Pqe "^([^: ]+:|)[^: ]+( < .+)$"; then
                        printf -- "%s\n" "error: invalid $is_multiline package specification '$value' (line $count)" >&2
                        printf -- "%s\n" "       You must specify obsoleted packages by defining the version number" >&2
                        printf -- "%s\n" "       the old unchanged package would have had if it had been normally released," >&2
                        printf -- "%s\n" "       i.e. the next higher version number." >&2
                        printf -- "%s\n" "       " >&2
                        printf -- "%s\n" "       Example: new-name v1.0.0 replaces old-name v0.1.0" >&2
                        printf -- "%s\n" "                -> Obsoletes: old-name < 0.1.1" >&2
                        printf -- "%s\n" "       " >&2
                        printf -- "%s\n" "       This ensures a clear upgrade path from 'old-name' to 'new-name'." >&2
                        error=true # global
                    fi
                else
                    if ! echo "$value" | grep -Pqe "^([^: ]+:|)[^: ]+( (<|>|=|<=|>=) .+|)$"; then
                        printf -- "%s\n" "error: invalid $is_multiline package specification '$value' (line $count)" >&2
                        error=true # global
                    fi
                fi
            }

            if [[ "$is_multiline" == "Screenshots" ]]; then
                if [[ ! -f "$value" ]] && [[ ! -f "$(dirname "$check_config_name")/$value" ]]; then
                    echo "error: screenshot file '$value' not found (line $count)" >&2
                    error=true
                else
                    screen="$value"
                    if [[ ! -f "$value" ]]; then
                        screen="$(dirname "$check_config_name")/$value"
                    fi

                    if (( "$(du -bs "$screen" | grep -Poe '^\d+')" >= 500000 )); then
                        echo "note: screenshot file '$value' is quite large; did you optimize all PNGs using '-S'?" >&2
                    fi
                fi
            elif [[ "$is_multiline" == "CompatibleVersions" ]]; then
                if ! echo "$check_versions" | grep -Pqoe "^$value"; then
                    echo "error: invalid version '$value' (line $count)" >&2
                    error=true
                fi
            elif [[    "$is_multiline" == "SourcePackages"
                    || "$is_multiline" == "Requires"
                    || "$is_multiline" == "Obsoletes"
                    || "$is_multiline" == "Conflicts"
            ]]; then
                __check_package_specification
            fi
            # END value checks for multi line fields

            if ! __check_dummy_value "$is_multiline" "$value" "$count"; then
                error=true
            fi

            continue
        fi

        if [[ "$line" != *":"* ]]; then
            echo "warning: comment lines should start with '#' (line $count)"
            continue
        fi

        if [[ -n "$is_multiline" ]]; then
            if (( lines_for_multi == 0 )); then

                if [[ "$is_multiline_required" == true ]]; then
                    echo "error: required field '$is_multiline' is empty" >&2
                    error=true
                else
                    echo "warning: empty multi-line field '$is_multiline' at line $is_multiline_at"
                fi

                line="$orig_line"
                value="$orig_value"
            fi

            is_multiline=
            is_multiline_at=0
            lines_for_multi=0
            is_multiline_required=false
        fi

        # BEGIN value checks for single line fields
        # single line
        is_single=true
        case "$key" in
            Prefix|DiscussionLink|DonationsLink|SourcesLink)
                # may be empty
                if [[ -z "$value" ]]; then
                    echo "note: no value given for '$key'"
                else
                    # special rules
                    if [[ "$key" == "Prefix" ]]; then
                        if [[ "$value" != "/"* ]]; then
                            echo "error: prefix must be an absolute path ($value; line $count)" >&2
                            error=true
                        fi
                    fi
                fi
            ;;
            DisplayName|Maintainer|Summary)
                # must not be empty
                if [[ -z "$value" ]]; then
                    echo "error: required field '$key' is empty" >&2
                    error=true
                fi
            ;;
            PackageName)
                # must not be empty
                if [[ -z "$value" ]]; then
                    echo "error: required field '$key' is empty" >&2
                    error=true
                fi
                # needs special rules
                if echo "$value" | grep -Pqoe "[^a-zA-Z0-9-_]"; then
                    echo "error: package name contains invalid characters (line $count)" >&2
                    echo "       allowed are: a-z, A-Z, 0-9, -, _ (no spaces)"
                    error=true
                elif echo "$value" | grep -Pqoe "^[-_]"; then
                    echo "error: package name must not start with '-' or '_' (line $count)" >&2
                    error=true
                elif [[ "$value" == "${check_default_dummies[$key]}" ]]; then
                    echo "error: package name not set (line $count)" >&2
                    error=true
                fi
            ;;
            Category)
                # must not be empty
                if [[ -z "$value" ]]; then
                    echo "error: required field '$key' is empty" >&2
                    error=true
                fi
                # needs special rules
                if ! echo "$check_categories" | grep -Pqoe "^$value"; then
                    echo "error: invalid category '$value' on line $count" >&2
                    error=true
                fi
            ;;
            Version)
                # must not be empty
                if [[ -z "$value" ]]; then
                    echo "error: required field '$key' is empty" >&2
                    error=true
                fi
                # needs special rules
                if ! echo "$value" | grep -Pqoe '^[0-9]+\.[0-9]+\.[0-9]+'; then
                    echo "error: version number must consist of three numbers separated by dots (X.Y.Z; line $count)" >&2
                    error=true
                fi
            ;;
            Release)
                # must not be empty
                if [[ -z "$value" ]]; then
                    echo "error: required field '$key' is empty" >&2
                    error=true
                fi
                # needs special rules
                if ! echo "$value" | grep -Pqoe '^[1-9][0-9]*'; then
                    echo "error: release number must be exactly one number without leading zeros (XYZ; line $count)" >&2
                    error=true
                fi
            ;;
            License)
                # must not be empty
                if [[ -z "$value" ]]; then
                    printf -- "%s\n" "error: required field '$key' is empty" >&2
                    error=true
                fi
                # needs special rules
                if [[ "$value" == "proprietary" ]]; then
                    printf -- "%s\n" "warning: it is recommended to publish patches with an open license" >&2
                    printf -- "%s\n" "         By putting the patch under an open license, you allow others to update" >&2
                    printf -- "%s\n" "         it for future SailfishOS versions in case you no longer maintain it." >&2
                elif ! __save_template_licenses /dev/stdout | grep -Fxqoe "$value"; then
                    printf -- "%s\n" "error: license must be a valid SPDX license id or the string 'proprietary', got '$value'" >&2
                    error=true
                elif [[ ! -f "$cDEFAULT_LICENSE_NAME" ]]; then
                    printf -- "%s\n" "warning: license text not found at $cDEFAULT_LICENSE_NAME" >&2
                    printf -- "%s\n" "         you can download it using the '-eL' option" >&2
                fi
            ;;
            *) is_single=false;;
        esac
        # END value checks for single line fields

        # multi line
        if [[ "$is_single" == false ]]; then
            case "$key" in
                SourcePackages|Screenshots|Changelog|Requires|Keywords|Conflicts|Obsoletes|TestCommands)
                    # regular fields
                    is_multiline="$key"
                    is_multiline_at="$count"
                ;;
                Description|CompatibleVersions)
                    # required fields
                    is_multiline="$key"
                    is_multiline_at="$count"
                    is_multiline_required=true
                ;;
                *)  echo "error: invalid key '$key' on line $count" >&2
                    error=true
                ;;
            esac
        fi

        if ! __check_dummy_value "$key" "$value" "$count"; then
            error=true
        fi

        if printf "%s\n" "${keys_found[@]}" | grep -Pqoe "^$key"; then
            echo "error: field '$key' is defined more than once (line $count)" >&2
            error=true
        else
            keys_found+=("$key")
        fi
    done < "$check_config_name"

    # check for required fields
    readarray -t required_config_keys_array <<< "$required_config_values"
    missing_required_defaults=()

    for r in "${required_config_keys_array[@]}"; do
        [[ -z "$r" ]] && continue
        if ! printf "%s\n" "${keys_found[@]}"  | grep -Pqoe "^$r"; then
            echo "error: required field '$r' is missing" >&2

            default=''
            if default="$(__get_default_config "$r")"; then
                missing_required_defaults+=("$r: $default")
            fi

            error=true
        fi
    done

    if (( ${#missing_required_defaults[@]} > 0 )); then
        printf -- "%s\n" "       the default value for new config files is:" >&2
        printf -- "%s\n" "${missing_required_defaults[@]}" | tee /dev/stderr | xclip -selection c && echo >&2
    fi

    # check versions
    to_check_list="$(sed '/^\#/d;/^$/d;s/^\s*//g;' "$check_config_name" | # remove comments, blank lines, and leading whitespace
        select_range "CompatibleVersions:" "^[^-]" | # extract the list between CompatibleVersions and the next section
        sed 's/^-\s*//g' | # remove leading '-'
        sort -V)" # sort by version
    to_check_latest="$(echo "$to_check_list" | tail -1)"
    to_check_latest_major="${to_check_latest%%.*}"
    upstream_latest_major="$(echo "$check_versions" | grep -Ee "^[0-9]+\." | sort -u | tail -1 | cut -d. -f1)"
    upstream_more_recent="$(echo "$check_versions" | sort -V |
        select_range "^${to_check_latest//./\.}" "^[^$to_check_latest_major]")"

    if [[ "$upstream_latest_major" != "$to_check_latest_major" ]]; then
        if [[ "$force" == true ]]; then
            upstream_more_recent="$(echo "$check_versions" | sort -V | awk "/^${to_check_latest//./\.}/{flag=1;next}flag")"
        fi

        echo "note: the patch is not marked to support the latest major SailfishOS version (v$to_check_latest_major vs v$upstream_latest_major)" >&2

        if [[ "$check_update_config" != true && "$force" != true ]]; then
            echo "note: if the patch is compatible, consider updating the CompatibleVersions section" >&2
            echo "      or use the options '-f -Cu' to update it automatically" >&2
        elif [[ "$check_update_config" == true && "$force" != true && -n "$upstream_more_recent" ]]; then
            echo "note: without the '-f' option, only the latest releases of the current major" >&2
            echo "      version (v$to_check_latest_major) will be added to the CompatibleVersions section" >&2
        elif [[ "$check_update_config" == true && "$force" != true && -z "$upstream_more_recent" ]]; then
            echo "note: use the options '-f -Cu' to update the CompatibleVersions section" >&2
            echo "      including major SailfishOS version upgrades" >&2
        fi
    elif [[ -n "$upstream_more_recent" ]]; then
        echo "note: there are newer releases for this major SailfishOS version (v$to_check_latest_major) available" >&2

        if [[ "$check_update_config" != true ]]; then
            echo "note: if the patch is compatible, consider updating the CompatibleVersions section" >&2
            echo "      or use the '-Cu' option to update it automatically" >&2
        fi
    fi

    if [[ -n "$upstream_more_recent" ]]; then
        echo -n "$upstream_more_recent" | sed 's/^/- /g' | tee /dev/stderr | xclip -selection c && echo >&2
    fi

    if [[ -n "$upstream_more_recent" && "$check_update_config" == true ]]; then
        # update CompatibleVersions
        latest_version_line="$(sed 's/^\s*//g' "$check_config_name" | # remove leading whitespace
            awk '/^CompatibleVersions:$/{flag=1;next}/^[^-# ]/{flag=0} { if (flag && $0 != "") print NR; }' | # print lines in 'CompatibleVersions:'
            tail -1)" # get the last line number
        update_config_name="$(mktemp)"
        cp "$check_config_name" "$update_config_name"
        update_to_add="$(echo -n "$upstream_more_recent" | sed 's/^/- /g;s/$/\\n/g' | tr -d $'\n')"
        sed -i "$latest_version_line s/$/\n$update_to_add/;" "$update_config_name"
        mv "$update_config_name" "$check_config_name" --backup=t
        echo "note: the CompatibleVersions section has been updated"
        echo "note: please check if the patch really is compatible with the new releases"

        # update version and changelog for new releases
        check_update_version=true  # NOTE it might be useful to make this optional
        if [[ "$check_update_version" == true ]]; then
            current_version="$(grep "^Version: " "$check_config_name" | head -1 | cut -d' ' -f2)"
            next_version="$(echo "$current_version" | cut -d. -f1-2).$(echo "$current_version+1" | cut -d. -f3 | bc)"
            sed -i "s/^Version: .*$/Version: $next_version/" "$check_config_name"

            last_compatible="$(echo -n "$upstream_more_recent" | tail -1)"
            sed -i "s/^Changelog:$/Changelog:\n\
- $next_version:\n\
- - update compatibility info: the patch is compatible with all versions of SailfishOS up to $last_compatible\n\
- - you may have to install an earlier version of this patch on older system versions\n\
-/"\
                "$check_config_name"
        fi
    fi

    if [[ "$error" == true ]]; then
        exit 1
    else
        exit 0
    fi
fi


__save_template_config() { # 1: output file
    cat <<EOF > "$1"
#
# SailfishOS Patch Configuration File
# for sailfish-patch
#
# Fields:
# - one line: Prefix, DisplayName, PackageName, Category,
#             Maintainer, Summary, DiscussionLink, DonationsLink,
#             SourcesLink, Version, Release, License
# - multiple lines: Keywords, Description, Screenshots,
#             CompatibleVersions, Changelog, Requires,
#             Obsoletes, Conflicts, TestCommands
#   (each line in a multiline field must start with '- ')
#
# Required:
$(echo -n "$required_config_values" | tr '\n' ',' | sed 's/^,//g; s/,/, /g;s/,$//;' | fold -w 70 -s | sed 's/^/# /g;')
#

SourcePackages:
$(__get_default_config "SourcePackages" | sed 's/^/# /g')

Prefix: $(__get_default_config "Prefix")
DisplayName: $(__get_default_config "DisplayName")
PackageName: $(__get_default_config "PackageName")
Category: $(__get_default_config "Category")
# Category must be one of:
#     Homescreen
#     Browser
#     Camera
#     Calendar
#     Clock
#     Contacts
#     Email
#     Gallery
#     Media
#     Messages
#     Phone
#     Silica
#     Settings
#     Keyboard
#     Others
Keywords:
$(__get_default_config "Keywords")

Maintainer: $(__get_default_config "Maintainer")
Summary: $(__get_default_config "Summary")
Description:
$(__get_default_config "Description" | sed 's/^/# /g')

DiscussionLink: $(__get_default_config "DiscussionLink")
DonationsLink: $(__get_default_config "DonationsLink")
SourcesLink: $(__get_default_config "SourcesLink")

Version: $(__get_default_config "Version")
Release: $(__get_default_config "Release")
License: $(__get_default_config "License")

# These commands can be run after deployment. They are for testing only and will
# not be run when users install the patch.
# TestCommands:
# - killall sailfish-office
# - sailfish-office

# Use @sources to mark all entries of SourcePackages as required.
Requires:
- sailfish-version >= 4.0.0
- @sources
$(__get_default_config "Requires" | sed 's/^/# /g')

# Conflicts:
$(__get_default_config "Conflicts" | sed 's/^/# /g')

# When renaming a patch or creating a patch that replaces another one, add
# all old names into this list. Make sure to define the next higher version
# number than the last released one.
# Obsoletes:
$(__get_default_config "Obsoletes" | sed 's/^/# /g')

# Screenshots:
$(__get_default_config "Screenshots" | sed 's/^/# /g')

CompatibleVersions:
$(__get_default_config "CompatibleVersions")

# Entries should be in descending order (most recent at the top), formatted like this:
# - x.y.z-r (yyyy-mm-dd):
# - - short summary of a change
# - - further summary of another change
Changelog:
$(__get_default_config "Changelog")

# kate: syntax SailfishOS Patch
EOF
}

__save_template_gitignore() { # 1: output file
    cat <<EOF > "$1"
documentation.list
RPMS
.directory
source-packages
original.tmp
diff_original_*.patch
diff_updated_*.patch
diff_apply_command.sh
diff_applying.patch
original-old-*
patched-old-*
source-packages-old-*
build.*
*~
EOF
}

__save_template_json() { # 1: output file
    cat <<EOF > "$1"
{
    "author": "@MAINTAINER@",
    "name": "@PACKAGENAME@",
    "display_name": "@DISPLAYNAME@",
    "version": "@VERSION@",
    "category": "@CATEGORY@",
    "description": "@DESCRIPTION@",
    "discussion": "@DISCUSSIONLINK@",
    "sources": "@SOURCESLINK@",
    "donations": "@DONATIONSLINK@",
    "compatible": [ @COMPATIBLEVERSIONS_LIST@ ]
}
EOF
}

__save_template_spec() { # 1: output file
    cat <<EOF > "$1"
Name: @PACKAGENAME@
BuildArch: noarch
Summary: @SUMMARY@
Version: @VERSION@
Release: @RELEASE@
Group: System/Patches
License: @LICENSE@
Packager: @MAINTAINER@
Source0: %{name}-%{version}.tar.xz
Obsoletes: %{name} < %{version}
Requires: patchmanager
@REQUIRES@
@OBSOLETES@
@CONFLICTS@

%define _source_payload w9.gzdio
%define _binary_payload w9.gzdio

%define _buildhost reproducible
%define clamp_mtime_to_source_date_epoch Y

%description
@DESCRIPTION@

%prep
%setup -q -n %{name}-%{version}

%build

%install
rm -rf '%{buildroot}'

mkdir -p '%{buildroot}/usr/share/patchmanager/patches/%{name}'
cp -r rpm_build/* '%{buildroot}/usr/share/patchmanager/patches/%{name}'

#
# Scriptlets:
# https://docs.fedoraproject.org/en-US/packaging-guidelines/Scriptlets/#_syntax
#
# - ensure that the patch is not applied while it is being installed/updated
# - ensure that it gets re-applied if it was applied before
# - ensure that it is not applied after removal
#

%pre
set -o pipefail

if mkdir -p '%{_localstatedir}/lib/rpm-state/%{name}'; then
    dbus-send --print-reply --system --type=method_call \\
        --dest=org.SfietKonstantin.patchmanager /org/SfietKonstantin/patchmanager \\
        org.SfietKonstantin.patchmanager.isPatchApplied \\
        'string:%{name}' | tail -1 | grep -qe '\\s*boolean true$'

    if [ \$? -eq 0 ]; then
        touch '%{_localstatedir}/lib/rpm-state/%{name}/was-applied' || true
    fi
fi

/usr/sbin/patchmanager -u '%{name}' || true

%preun
/usr/sbin/patchmanager -u '%{name}' || true

%posttrans
if [ -e '%{_localstatedir}/lib/rpm-state/%{name}/was-applied' ]; then
    /usr/sbin/patchmanager -a '%{name}' || true
    rm '%{_localstatedir}/lib/rpm-state/%{name}/was-applied' || true
    rmdir '%{_localstatedir}/lib/rpm-state/%{name}' || true
fi

%files
%defattr(-,root,root,-)
%{_datadir}/patchmanager/patches/%{name}

#
# Changelog:
# https://rpm-packaging-guide.github.io/#working-with-spec-files (section 5)
#
# The RPM changelog should only contain packaging changes but we include the
# whole patch changelog because it allows Openrepos to extract it automatically.
#

%changelog
@CHANGELOG@
EOF
}

__save_template_qmldetails() { # 1: output file
    local script="${cSCRIPT:-sailfish-patch}"
    [[ "$script" != "sailfish-patch" ]] && script="$script (sailfish-patch)"

    cat <<EOF > "$1"
// This file was rendered by sailfish-patch for @PACKAGENAME@
// SPDX-FileCopyrightText: 2023 Mirian Margiani
// SPDX-License-Identifier: GPL-3.0-or-later

import QtQuick 2.2
import Sailfish.Silica 1.0

Column {
    id: root
    property string author: "@MAINTAINER@"

    width: parent.width
    spacing: Theme.paddingMedium

    SectionHeader { text: "Patch details" }

    Column {
        width: parent.width
        spacing: Theme.paddingSmall

        DetailItem {
            label: "Author"
            value: author
        }
        DetailItem {
            label: "Maintainer"
            value: "@MAINTAINER@"
            visible: author !== "@MAINTAINER@"
        }
        DetailItem {
            label: "License"
            value: "@LICENSE@"
        }
        DetailItem {
            label: "Version"
            value: "@VERSION@-@RELEASE@"
        }
    }

    Item { width: parent.width; height: 1 }

    ButtonLayout {
        columnSpacing: 0
        preferredWidth: Theme.buttonWidthLarge

        Button {
            text: "Discussion"
            onClicked: Qt.openUrlExternally("@DISCUSSIONLINK@")
            enabled: visible
            visible: "@DISCUSSIONLINK@" !== ""
        }
        Button {
            text: "Sources"
            onClicked: Qt.openUrlExternally("@SOURCESLINK@")
            enabled: visible
            visible: "@SOURCESLINK@" !== ""
        }
        Button {
            text: "Donations"
            onClicked: Qt.openUrlExternally("@DONATIONSLINK@")
            enabled: visible
            visible: "@DONATIONSLINK@" !== ""
        }
    }

    Item { width: parent.width; height: 1 }

    Label {
        text: "Full details are available on Patchmanager's patch details page. " +
              "Go back to the list of patches, then press and hold the patch " +
              "entry to open the context menu. There you can access patch details " +
              "and enable/disable the patch."
        x: Theme.horizontalPageMargin
        width: parent.width - 2*x
        color: Theme.secondaryHighlightColor
        font.pixelSize: Theme.fontSizeExtraSmall
        wrapMode: Text.Wrap
    }

    Item { width: parent.width; height: Theme.horizontalPageMargin }
}
EOF
}

__save_template_icon() { # 1: output file
    # original optimized patchmanager icon png, encoded with 'base64 icon.png'
    cat <<EOF | base64 -d > "$1"
iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAMAAACahl6sAAAAGXRFWHRTb2Z0d2FyZQB3d3cuaW5r
c2NhcGUub3Jnm+48GgAAAAlwSFlzAAAgJAAAICQBcEDPXgAAAwBQTFRFR3BMpbCrwMW7y8zCvr++
b5GJn6+meJaOvMC6kqefg52VfJmRzMzCdZWNu8G3xMe9n62nb29vnK2kdnh3obGorLatx8m/lKif
sLqxn62nvL68tLu0kpOTgIeEorGonq6lmaihiqCZoaOil6aguLq5q7etmpyborCoj6Sci4yMq66s
ycrAjZqVlqmhkZqWjqScrbWwsbmxsbizkKadiqKZi6GZsrqxqrSsh4+Lhp+XeXp6mKuijqScgYGB
s7qyhZ2Vg5aQnK2khoeGjJSQu8G4nq6luKOAiKGYs7uzu8G5paqkb3VziI2Lp5hffIiDg5ONtr20
5axu7Ld33qJnhJ6Ws7yztL2zkKadsruyhp+Xlamgtb20sbuxiqKZqratl6qhn6+mnK2kmKuig52V
jKObrbivuL+2wsW8rLiugZyUvsO6rLeueZePucC2na6lwMS7iKGYoLCnw8a9mqyju8G4jaSbf5uT
iaGZvMK4qLWsfpqShZ+WsLqxi6Oat761xMe9fZqRpbOqfJmRprSrgp2UdpWNpLOpj6Wco7KporGo
epiQkaaekqeedJSMh6CYvcK5/PTrp7SrlKifh6CXyMm/d5aOtr61e5iQr7qwr7mwrrmvrrmwt7+1
zMzCjqWcjqScxci+ycrAgJyTc5OLcZKKusC3usG3gJuTqbasxsi+bpCIk6efcJGJk6ify8vBobGo
iKCYiaGY5Kttd5aN46lsj6Wd4adqp7Wrm6yjlKignK6lobCn3aFn4KRpKNpO2p9l26Np/QEA1pxj
6LBxzZhh7bt94K1z0ppi6rN0ypJd16BmwrWY++/h0rSI8ciXvKyMyrSPs7Wk37Z/rK2Y78CHtKyS
1aNuyqyCvLeg1LB/996/v6V/w66Kt7CWoKKN0aV0rKOHtp9da7pU+ejTx6R42a1457d6lqSVmqRY
WcFSpK2fqrKlnqmaRctQ+OTL1HlN7hkP11c3kKxZLddOONFP89Go9Nay4TQhoZZVebNVwZNcraqR
mKtptY1XtamMiKlV/zDAIwAAAFF0Uk5TALzZ2JvICBC1FcnIkMjYkNXvLOlU9ddEj8amysDmOh3n
8bXVoHu94/XJqo/s8NZrtuClu4H8+evon96j49Rk+fKKzeLy8fmx7uLv/tb3/f75d9R9tAAAEZJJ
REFUeNq823tMVFceB3BdJhS7GyswCJ1BoAqyohWwBnw0JFZUNPuHM1MBUURYcbtM7OoqK0RwY9gI
RlNAG6PWWttE103T7Tqho7udGcZheMvLF4gWeYjgExFfQKx7zp0ZmJl7zp1z597DNyaakBg/Oed3
Hr9znTSJVt4J9gnyl8bFhQWAvBcQ6oVKnGzsj7L3kJlrl9+hMzfOk4rA00caFipPSEzcsOHohqNH
T+7de/LkVpBtIGfOnD27CyQHpLi4ePWSRVlZWX9h8idr/gryd5jTp0//C+RLJt8y+TeTr1nxEFvi
KQ2Iik5OXrduXXJiIpQACwhWEj/TO0cUyVwxEUFh8piNG5Nh1sEQSLLkvllZYkimi6UICouKOZaX
dyxvo4VCKpnqXSyKxEMUhU9A9FdfHT9+DEjy+EmKp/quFUUiAmRKnDwz88QJNyVefwAlL4LEQ3Bx
R6k/y8x0XyLzLRZFIgwSHOCnVqs/EyKJWJ4jisRDUGX4qTephUlyZi/KEUXiPsRnwSYQtVqYJH7m
8hxRJO5CgiJyz20SQRIfuCZHFIl7EJ/JuedyRZHEzwnZJYrEHYhnQOmFXBjhkpz4wHm7RJG4AZGG
lxaIJlkdGLNLFIkH/1lVcKGgtFQsyeolfrtEkfCEeIbt31cAIprE65OYs6JI+EGCwveBiCjJkS9Z
c1YUCS9IWNH+fSJLVgd6nxFFwgMyZXJRkeiSs3LvGaJIPHhMq6IiCpJtcu81YkiIIWEHDhTRkGyN
D/T2E0HiQTqtDhygJNm2eo7vGeESMohP+I8/0pN4ec8TLiGCBK3Y8TNNyWTvWMESEoh0844dNCXR
kk/WbhMqIYDEQQdFSbRMlsDu3PGVuIaEbd5MVZIQKotF9SB5SlxClm3+nKokXBYav3WvcIkryFLI
oCfZO00iS8D1hflIvvRw6aApSZRLvNbiO9x8JNyQZZ/DUJNAhx9Hh5uHhHtEItP/R1MS874kai1n
r56HhKuJLU1PpynZAMYjxsWrA7HkWw6I/8V0qpJpkqhkl+8nxBI8xGdFejpNSQKoD4KXIFIJFhIc
svMiTUmMLMKP5P2EVIKDeL6/cydViVwSQvYSRCjBQZbt3ElVEi2ZT/qmRSbBQPwzMqhKYrwi1iSL
KkFDgj/MoCuRS+bzeGckkUxHF0hGBlVJgmQmr7dfAgkSsiwtg6okQSYJ4ff261qCgvinpVGV5Mkl
0/i+YruUICBTPkyjK4mWBKrzxJYgIEvT0qhKYmVeMbxfsV1K2JCglBSqkgSwpbvxHu9KwobMSqEq
OeclCXHrywIXEhYkMiWFqkQumeXmNxLckumsSk+hKomVzHb7aw9OiTNk6eH/0pSEh4aGZFKROEH8
Dx+mKMmMlcn8BHy3wiX5jVOl/0BT4hcRGi7oCxwOiSNE+v0PNCXRkmnCvsDhkDhCZn1PUxIrmbNG
TUviAPE/dIimxCvUT62mJXGAfHSIpgRcCoV+S8QhsYf4HzyEkVy83nR99OoDIZILsbLZuZvoSewh
Hx1ES0ZbqxRMqlqvP3BX4hcq8xPh+y6sxA4SlJSEkjzqVdiiAb96b191R7IpKiJWjO+7sBI7yKok
lORRlcIxQHOz6SpfSaxkvjhfquEk45DgpCSEZNTZYbVUtTY94CHZJ5u9IpeqZByy8CeE5BHKYUsv
KBlCSaxkljjfd2El45CPCxGSJgV3YMlsJpD4Bc7LpSsZgwQVFrIlKVUK19GAknEpCVx+ga5kDLL4
FELSpCAMXJg5JbMXldKV2CCevz+FkPQqeKS39ZefsZKZM0rpSmwQ6TffsCWPFDyjuXn7anNDQ/1D
lmSybylVSZYNsiobIflVwT8VSpgrzb88dJBE+RbQlVghU7KzEZJWNyBKW+5daW4Zk+yX++6jK7FC
IrNRkiohEAbTUN9ikci95xVQlVghi7cgJNgS0Wg03DPLCfMQSAJnFFCVTLXuhlsQEsziqymDwVBq
lKhcaW6b7F1AVWKB+OTnsyUH72AcWqPRqNUQzCyH3GlqKaUnsUIi8xGSQ5gB0RqfDXcZ0UNSoeQK
LBlaEgtkVT5bUjiKhpQZq+8b7tehh6RG6SpXQMnQkFggH+QjJLcwM8toHjI8cxtiLZlzYksYiE9q
KkLSi5lZdf0GQxcGoiROQ3OLqBIGEpmKkPSVIRdZMLO6DY/NxjKSEqmsdFUyokkYyKpUhKRTq4Wr
rGZs77BBzI8N3dVoiOPMutZeUnL5ZaWLkmlTiyJhIB+nIiS39FoYaNHY9g4NnFldBmyJODoul8D0
VBKUjHAJhHju3o2Q3FDp9RaLtkwLtw6weQCW0fTMYBghgTwpseQlQcXcqxcqgRCf8whJnwpGb8Ho
jV3PuszVdXVGY53ZUiIaVyVyzeoouUxU/EIlECLdzpYUdqpsARZdXbfB8Li7f8RsNo88NwxDiMZF
ifCEVFTdrG8RIIGQhdsRkrsqu5Sbhh8bQIYeD/e/Nhj6zXVGbRnboiSEoKqmgrkxg3XMTQmELN6O
kBjtHLpyU3Vt19v7zw2WvB4B08zIWDh2kR5MjbwAP3jS6AwZ65j1NredcEMCIe/+hy3psB8QIAEU
c23t6+H7Q1DyvJspGUDR4HcRzKrVbuE5SWoc+n83AYanBEI++IIlyV6pcpRACrSMvBkyWAYGlAyY
YfYS5/MJs4+0Ozka0ROugtWXASXDRwIgwUe+YEvuqFTOFB0zw0CJvH7ztpvBDHXX6e0qBTHz2dXQ
biudRsTMcsY01B8nlQCI/xG2pE+nYgdKaocNz0dqQZiS6WaKvsxyY6wgWp1su0vJC9cQpsnU3LaR
RAIg0iNsSacKFV15dS04wtdWw1kGSqarq06lt2z/AEN28kWPSA1nHwCUjEsJgESuZ0l238JBRoYM
b82m8nKmZEymcp3etv+XkUHGaqSSs0QQs6yFUwIhe9iSGxiIGRzh31SX65iKKYe/W7dMICE8v7cT
lwhrljXU4yUAsnD9epZEhYaYasH5pBZAbPVvt/1rSG8iL8Cy3NOo5A+BA1OPk0DIHpakD1si4Ahf
a9KhloIK8ksV65pSQ943q6pHSwBk8R6WBAt5A88n5SiHqkbpfir4tACbkRILxFnSgYM8MwyNVCMh
egEOJb9mJnJMAGTVpywJFtINFl8TEqIR4Kjh2ZZtQ0gYCEuSakRDTOb+fvSA8CkRwZAqRMUDyLuf
siW4fcQEtw4kRDlRJcJMLpZkgxXiLMHMLbh5oB3aiSsRkAb2fiK3Qpwk540qHAXpUCkmcGaBsPd4
CPkjQtKB/vdiUzORMwuUO0viBSEoSSc/yITOLAvEUbKAgaAkK/k4yiYY0sL6XxsSCwQ5JjfIIQpe
vVLBJaJIZJ3qAwDkHxjJeXKKY4k09oBj+gviAeF4ycNlI+t+EgYhOMn28x23iCx61JWjnRBSZuvL
8tgRWXfGoxYIXrJ7d1/n3Ru8SqTyMvJWjp1Zth5zGbmlgX2PjwOQP3NLwPWko/OukQtSgboDEg6J
QjV+ySTF1LM7ElIIcS0B9/iOlXd0RIvvCxvkCRFEqxq/ZDIaglmG6K0EMRAiSX5qXye6ZLRKwhFB
rWUq+yazVjdg6ftxYnoR/a53LBAyCexB9iFmmdPii6mRynbwg/ZrziXi+FeZn156OjhgsmCwVyt2
5y4Bdky/4yXZkp3dsfKujuMIj161Ki294MvXnEvEPsaBS0xecWLaWN3UZHDUmvTb73hLTmUXdty6
gz2fND4pKelx3kdeWsepB1UiY4fSgaeXrHn6arC2julksjCIvvACCPknfwnzpmUrGS1Rr9Q24Uqu
YUrE1t8YfGWHGdCNtzLH+nXsXv26MAbirgS+/YKSITtooSEVqNubPaZaz1qYmxGvDlII+ZsASVLh
T0m/CoBo0DfR8urqgcFXcExMdruMdWBaEC9BPgxEiAR+I3H9HgHkJXJ30eO2Jjgw5oHBwTqHXQZi
qhBvWjGeFohQSdJo002XXTnUqlXDefIBmLFOx/jAtCLeGaMnWSFCJcByePT2FW7Jy//3di+vbRxh
AMBnYS0jF8NKqyAv0VralawXkqxKFpFlqZJt0h5skkMKIoLQJujQQC7GiEJpoC20bhu1EEPpLYak
0OLUmPRBW1qDIccQVCJkY2zjS/HBzn8QKJUs2dZjdrWzO18HHXX5MfvNY+f7ZnvnkadEu7cm5hnm
xDR2AvmAgqSVc1fbPiR6V/rLNdK2sYE7+32jCaEnKZfLLys7h5o3VdfI2wHuPN7ZglCVlB8vV/s8
ZdpCBN+2MZkFJyFyAqEseby2Vn/KXmhYwpO3fUzeykgT8hGIZHl5+WXt+aGGJTxZ+6E3l+hDWwsC
JikUCtU3d+iGCC6/y9yEfAIn+aNQcIjvKIXMUx2QPUym2kXUgkBKfHKoUTuHfcp+0gHB5dyNnEEA
Ja6M1KwCLBSOKl0YHSGyicuDtJ9D4CThTKi9xrS6t2MoRLYxGZ2vozYImIQLSJ3Vsou/1/5+oXvw
rWCybEc6IFASLlXG1P0e7T/f2Xu1e/AXcYhg8oWtp5BvASVlX8qPq2C+tbh4s/67+Wp3i8Sxhcnh
vojOIJASVybUpxb76N9/NGP2MNnoY20QQEl4JqShqrxaUX+VeTpmHWMqBJxnkC8hJeFAUmN9fLV/
yOxhah2i6BwCKnEktVf6H9VUQ2bzuLf+5D1bOwRS4hXJ7iyoh4zCU7a5j6kJumTqgABK6hAyycLC
u9XKQQ9mY6uKuxFj7LyO/bU7oBKZ13WPxJ+13c68yoNj3I0YFwbbIaAShtd5I8b6+lFtuxUym9v7
+Bsx2jqkAYGUNCAG7vY4rtZqldrnX+Dv9rhgboMM34GUrAmWMtgtJfdHUDcETsJZ7oFJ7jt7IWAS
jveDSTo6BA1/AyoJZ8R7UBJnFwRU4pLFPJCks0MaEFCJzOdhJJcGeyGQEobPg0h+s3VdOzf8M6yE
seRBJAzqgYBK8oIlDyH52NoD+RRWwll+hZBMo14IrITjVwAkPhMOAipxpaQl+hIbwkIgJa5MaIm2
5LMgUoAASsIzoSXaEp9ZEQIn8QeSD2hLRnE3YA9/BSxxJB9QlowhPARY4hBXqErWGaQEgZUE+BWq
EmyAtCCQEn9mLkFVMopUIHCShDCTmrtKUTKGVCFQkpKbdbtkPkdLsj6l+MWU4UeQEj/rSBTry5Qr
lCSMSQUCJ3nf7/bMNiKeSc3RkCwIyo4GBE4SCbqaY5cQmCsal3BmlY8jDTyCk/jZ+dNRmPMa7xOf
E/WDAEmisnQ2n3ABo2PXZSvqDwGRCGygbWaMzmcNSS6Pqn/PbeA7KImXZRLtM6PA3zAg6eeoQ4Ak
7rqjY44PB6+U9EoWfVbUHwIjiclPulYrDF/SK+GcSAsEQiKwYve6i5sJXde37hLMSBuEvkRi5Wz3
usvPeQNioD7Lk0pU5vM2yI8Qkq9jQcx9K/VB2MUxMYmwT6a0OOoQCEnaM6+402KSZE/XtLbPMdch
ABImmFTaaa1EIyRxErYj7RDqErcnorxnFOS72iWCE5FAaEvSMq+8Z3SxVzWPwtMIkUFoSwRLVlFS
8kQ0zicuOyKGUJZImZzS7rdY5DxPtEhuxZ2IBLIKIZFmRMV9fNHPRkr9JeFxhMggEJLrXktWSVK8
y7GzN/pJpsyIGAIhSadyKu9WBNat3iduO0I6IAASKZBUeUtU8rvUclPDEyakDwIgcYi6c1PJgrwT
Ql8iW3Tm3MXtCBmAUJe4eVGPJD6KkDEIbUnaK5JnRU1ZETIMoSrJhWJyljRvxQijHUJP8jCSiUUl
ssyC9IQTIUoQWhIx4Imm3yY5MfVP2pHR1g6hIcmlvB5GyJGcacVtJoToQgxLcrNyjJFu3/5e6/mJ
Pz5uRlRaJ8SgZNbBBrOaTx0S8Qm7CdFqk6vUJKKDjUpZbe+FE0M0ESe3xq9SkogR1uN+2P/NnTQ0
OWGz0kU0P1Y3QEOS8wYZIaS0Fs6GIkNDb01OTozbnQiumQb1NvNZM5lMZkxr/g39D+0/vSJX7FTe
DDsAAAAASUVORK5CYII=
EOF
}

get_single_config() { # 1: config file, 2: key, 3: default value
    # we can safely assume the file exists and is valid
    # which means we can also assume the key exists if it is required

    local line="$(grep "^$2:" "$1" | head -1)"

    if [[ -z "$line" ]]; then
        echo "$3"
        return
    fi

    local key="${line%%:*}"
    local value="$(trim "${line#$key:}")"

    if [[ -z "$value" ]]; then
        echo -n "$3"
    else
        echo -n "$value"
    fi
}

get_multi_config() { # 1: config file, 2: key, 3: default value
    # we can safely assume the file exists and is valid
    # which means we can also assume the key exists if it is required

    local key_at="$(grep -nr "^$2:" "$1" | cut -d':' -f1)"
    local lines=()
    readarray -t lines <<<"$(tail --lines=+"$((key_at+1))" "$1")"
    local selected=()

    for l in "${lines[@]}"; do
        local first="${l:0:1}"

        case "$first" in
            -) selected+=("$(trim "${l:1}")");;
            "#") echo -n;;  # ignore comments
            *)  if [[ "$l" == *":"* ]]; then
                    break # is next key; done
                else
                    echo -n # ignore as comment
                fi
            ;;
        esac
    done

    if (( ${#selected[@]} == 0 )); then
        echo -n "$3"
    else
        printf "%s\n" "${selected[@]}"
    fi
}

config_checker="$0"
require_config() { # 1: expected config file location
    local config="$1"
    if [[ ! -f "$config" ]]; then
        echo "error: could not find config file" >&2
        return 1
    else
        "$config_checker" --check-config "$config"

        if (( $? != 0 )); then
            echo "error: config file contains errors" >&2
            echo "       please check the output above and try again" >&2
            return 1
        fi
    fi

    return 0
}

# return unchecked base config path to be used
# in validator functions
__get_config_path() {
    local found=
    local old_name=CONFIG

    if [[ -f "$cDEFAULT_CONFIG_NAME" ]]; then
        found="$cDEFAULT_CONFIG_NAME"
    fi

    # Before 2019-07-04 (< 2.0.0), config files were expected below 'build'.
    # The documentation was fixed only on 2021-05-08 (2.4.0). If we encounter
    # a config file in the old location, we move it to the new place or fail if
    # it already exists.
    if [[ -f "$(pwd)/build/$old_name" ]]; then
        if [[ -z "$found" ]]; then
            mv "$(pwd)/build/$old_name" "$cDEFAULT_CONFIG_NAME"
            found="$cDEFAULT_CONFIG_NAME"
            echo "warning: config file moved from 'build/$old_name' to './$cDEFAULT_CONFIG_NAME'" >&2
        else
            echo "warning: another config file found at build/$old_name" >&2
        fi
    fi

    if [[ -f "$(pwd)/build/$cDEFAULT_CONFIG_NAME" && "$cDEFAULT_CONFIG_NAME" != "$old_name" ]]; then
        if [[ -z "$found" ]]; then
            mv "$(pwd)/build/$cDEFAULT_CONFIG_NAME" "$cDEFAULT_CONFIG_NAME"
            found="$cDEFAULT_CONFIG_NAME"
            echo "warning: config file moved from 'build/$cDEFAULT_CONFIG_NAME' to './$cDEFAULT_CONFIG_NAME'" >&2
        else
            echo "warning: another config file found at build/$cDEFAULT_CONFIG_NAME" >&2
        fi
    fi

    if [[ -z "$found" ]]; then
        # the path has to be checked outside of this function
        found="$cDEFAULT_CONFIG_NAME"
    fi

    echo -n "$(pwd)/$found"
}

# return unchecked base build path to be used in
# validator functions
__get_build_path() {
    echo -n "$(pwd)/build"
}

# return path of latest package build
# assumes build path and config have been checked before
__get_package_path() { # 1: type (rpm/tarball)
    if [[ "$1" != "rpm" && "$1" != "tarball" ]]; then
        echo "internal error: invalid package type requested" >&2
        return 1
    fi

    local extension=""
    if [[ "$1" == rpm ]]; then
        extension="noarch.rpm"
    else
        extension="tar.gz"
    fi

    local config="$(__get_config_path)"
    local package_name="$(get_single_config "$config" "PackageName")"
    local version="$(get_single_config "$config" "Version")"
    local release="$(get_single_config "$config" "Release")"
    local package="$(find "$(__get_build_path)" -maxdepth 1 -iname "$package_name-$version-$release.$extension" | sort --version-sort | tail -1)"

    echo -n "$package"
}

# return default original files path
__get_original_path() {
    echo -n "$(pwd)/original"
}

# return default patched files path
__get_patched_path() {
    echo -n "$(pwd)/patched"
}

# return default source package path
__get_sources_path() {
    echo -n "$(pwd)/source-packages"
}

# return default extras path
__get_extra_path() {
    echo -n "$(pwd)/extra"
}

require_build_config() {
    # require valid config
    local config="$(__get_config_path)"
    require_config "$config" || return 1

    # require build dir
    local build_dir="$(__get_build_path)"
    if [[ ! -d "$build_dir" ]]; then
        echo "note: creating new build directory" >&2
        mkdir -p "$build_dir" || {
            echo "error: failed to create new build directory" >&2
            return 1
        }
    fi

    return 0
}

require_current_package() { # 1: type (rpm/tarball)
    require_build_config || return 1
    local config="$(__get_config_path)"
    local build_dir="$(__get_build_path)"

    # find package file
    local package="$(__get_package_path "$1")"

    if [[ -z "$package" ]]; then
        echo "error: no $1 found" >&2
        return 1
    fi

    return 0
}

# create diff and save it to $2
# assumes config is valid
__create_diff() { # 1: config, 2: save path
    shopt -s extglob
    local prefix="$(get_single_config "$1" "Prefix" "/")"
    prefix="$prefix/"            # ensure trailing slash exists
    prefix="${prefix//+(\/)//}"  # remove duplicate slashes
    shopt -u extglob

    local save_path="$2"
    [[ "$save_path" != /* ]] && save_path="$(pwd)/$save_path"  # make absolute

    local patched="$(__get_patched_path)"
    local original="$(realpath -m "$(__get_original_path)" --relative-to "$patched")"

    pushd "$(__get_patched_path)"
    patched="$(realpath -m "$patched" --relative-to .)"

    # git diff --patch --relative --text --no-index --src-prefix="a${prefix}" --dst-prefix="b${prefix}" -- "$original" "$patched" > "$2"
    git -c core.quotepath=off diff --patch --text --no-index --src-prefix="a${prefix}" --dst-prefix="b${prefix}" -- "$original" "$patched" |\
        sed -Ee "s@(--git|---|\+\+\+) (\"?)(a|b)${prefix}(${original#/}|${patched#/})/@\1 \2\3${prefix}@g;
                    s@(--git a/.*) (\"?)b${prefix}${patched#/}/@\1 \2b${prefix}@g;
                        s@(---|\+\+\+) (.*?)\t@\1 \2@g;" > "$save_path"

    popd
}

# make sure that we are currently in a valid git repository
# returns 0 if in a repo, and 1 otherwise
require_inside_repo() { # 1: quiet?
    if git rev-parse --git-dir >/dev/null 2>&1; then
        return 0
    else
        [[ -z "$1" ]] && printf -- "%s\n" "error: '$(basename "$(pwd)")' is not in a Git repository;" >&2
        return 1
    fi
}

# make sure that we are currently *not* in a valid git repository
# returns 0 if *outside* of a repo, and 1 otherwise
require_outside_repo() {
    if require_inside_repo 2>/dev/null; then
        if [[ -z "$1" ]]; then
            printf -- "%s\n" "error: '$(basename "$(pwd)")' is inside a Git repository;" >&2
            printf -- "%s\n" "       sailfish-patch heavily relies on having only one" >&2
            printf -- "%s\n" "       patch per repo" >&2
        fi

        return 1
    fi

    return 0
}

# initialize a new git repository in the current working directory
# returns 255 and prints an error message if there is one already
__setup_git_repo() {
    require_outside_repo || return 255

    git init || {
        printf -- "%s\n" "error: failed to initialize a new Git repository" >&2
        return 1
    }

    local defaultbranch
    defaultbranch="$(git config --global init.defaultbranch)"
    [[ -z "$defaultbranch" ]] && defaultbranch=main

    git checkout -b "$defaultbranch" || {
        printf -- "%s\n" "error: failed to switch to the default branch '$defaultbranch'" >&2
        return 1
    }

    require_inside_repo || {
        printf -- "%s\n" "error: failed to setup a new Git repository" >&2
        return 1
    }

    return 0
}

__print_initial_help() { # 1: original path, 2: patched path, 3: extra path
    local title="Short How-To"
    local original="$(basename "$1")"
    local patched="$(basename "$2")"
    local extra="$(basename "$3")"

    [[ -n "$create_new_name" ]] && title="$create_new_name -- $title"

    cat <<EOF
== SailfishOS Patch: $title ==

1. configure the patch by editing '$cDEFAULT_CONFIG_NAME'
    - add all source packages to the 'SourcePackages' field
    - update basic info about the patch
    - run '$cSCRIPT -C $cDEFAULT_CONFIG_NAME' to check for configuration mistakes
2. bootstrap sources by running '$cSCRIPT -u'
    - note: it must be possible for '$cSCRIPT' to connect to your device via
      SSH if you want to use source packages from the official repos. Make sure
      this is configured correctly. This is not needed for OpenRepos sources.
    - alternatively, put original sources in '$original' and copy them to '$patched'
3. commit clean sources
4. make any changes in '$patched'

5. optionally: add extra files like translations, icons, or settings to the
   '$extra' directory
    - allowed file extensions: .qml, .js, .png, .svg, .qm
    - translations files must be named 'translation_LANG.qm'
    - patch icon must be named 'main.png' ('main-light.png') or 'main.svg' ('main-light.svg')
    - patch settings page must be named 'main.qml'
    - no sub-directories are allowed
    - see https://coderus.openrepos.net/pm2/usage/ for further details

For updating the patch to new upstream versions, simply run '$cSCRIPT -u'.

Tips:
- Use 'rpm -qf /path/to/file' to find out which package a file belongs to.
- Use 'pkcon get-details packagename' to check which version is installed.
- Use '$cSCRIPT -b -p' to test the patch directly after building (needs SSH).
- Do not push your patch to a public repository. Instead, publish the 'code
  distribution package' which includes only the files that belong to you.
  Other users can rebuild the development environment by running
  '$cSCRIPT -u' in the published directory. This way, you do not have to
  publish potentially copyrighted material without permission.
EOF
}


if [[ "$create_new" == true ]]; then
    if [[ -e "$create_new_name" ]]; then
        echo "error: a file or directory with the name '$create_new_name' already exists" >&2
        exit 1
    fi

    mkdir -p "$create_new_name"
    cd "$create_new_name"

    __setup_git_repo || exit 1

    mkdir -p "$(__get_extra_path)"
    mkdir -p "$(__get_original_path)"
    mkdir -p "$(__get_patched_path)"
    mkdir -p "$(__get_sources_path)"
    mkdir -p "$(__get_build_path)"

    __save_template_config "$cDEFAULT_CONFIG_NAME"
    __save_template_gitignore "$cDEFAULT_GITIGNORE_NAME"
    __save_template_copying "$cDEFAULT_LICENSE_NAME" "$(__get_default_config "License")"
    __save_template_qmldetails "$(__get_extra_path)/$cDEFAULT_QMLDETAILS_NAME"

    git add "$cDEFAULT_CONFIG_NAME" "$cDEFAULT_LICENSE_NAME" "$cDEFAULT_GITIGNORE_NAME"
    git commit -m "patch skeleton automatically created by sailfish-patch"

    echo "patch created: $create_new_name"

    __print_initial_help "$(__get_original_path)" "$(__get_patched_path)" "$(__get_extra_path)"

    exit 0
else
    __update_is_valid_version() { # 1: comparison (>, <, >=, <=, =); 2,3: versions to compare
        local comparison="$1"
        local check_1="${2%%-*}" # strip release
        local check_2="${3%%-*}"

        get_largest() {
            printf '%s\n' "$@" | sort --version-sort | head -1
        }

        get_smallest() {
            printf '%s\n' "$@" | sort --version-sort | tail -1
        }

        ok=false
        case "$comparison" in
            ">") if [[ "$(get_largest "$check_1" "$check_2")" != "$check_1" ]]; then
                    ok=true
                fi
            ;;
            ">=") if [[ "$check_1" == "$check_2" || "$(get_largest "$check_1" "$check_2")" != "$check_1" ]]; then
                    ok=true
                fi
            ;;
            "<") if [[ "$(get_smallest "$check_1" "$check_2")" != "$check_1" ]]; then
                    ok=true
                fi
            ;;
            "<=") if [[ "$check_1" == "$check_2" || "$(get_smallest "$check_1" "$check_2")" != "$check_1" ]]; then
                    ok=true
                fi
            ;;
            "=") if [[ "$check_1" == "$check_2" ]]; then
                    ok=true
                fi
            ;;
        esac

        if [[ "$ok" == false ]]; then
            return 1
        else
            return 0
        fi
    }

    # we assume config has been checked before and is valid
    __update_fetch_latest_sources() { # 1: optionally a suffix for source backups
        local original="$(__get_original_path)"
        local config="$(__get_config_path)"
        local packages="$(__get_sources_path)"
        local extract="${packages%/}/extract"
        local base="$(pwd)"
        local -r openrepos_url="https://sailfish.openrepos.net/"
        local packages_backup=''
        [[ -n "$1" ]] && packages_backup="$packages-old-$1"

        if ! rm -rf "$original"; then
            echo "error: failed to remove old original sources" >&2
            return 1
        fi

        if [[ -d "$packages" ]]; then
            if [[ -n "$packages_backup" ]]; then
                mv --backup=t -T "$packages" "$packages_backup"
            else
                rm -rf "$packages" || return 1
            fi
        fi

        if [[ -d "$extract" ]]; then
            rm -rf "$extract" || return 1
        fi

        if ! mkdir -p "$extract"; then
            echo "error: failed to prepare temporary files" >&2
            return 1
        fi

        if ! mkdir -p "$packages"; then
            echo "error: failed to prepare temporary files" >&2
            return 1
        fi

        local sources=()
        readarray -t sources <<<"$(get_multi_config "$config" "SourcePackages")"

        if (( ${#sources[@]} == 0 )); then
            # nothing to fetch
            return 0
        fi

        updated=()
        for s in "${sources[@]}"; do
            local source="$(trim "${s%% *}")"
            local version=
            local version_action=
            local file="$packages/${source}.rpm"

            if printf -- "%s\n" "$s" | grep -Pqoe " ([><]=?|=) "; then
                version_action="$(grep -Poe "([><]=?|=)" <<<"$s")"
                version="${s##* }"
            fi

            if [[ -n "$update_local_sources" ]]; then
                [[ "$source" == *":"* ]] && source="${source#*:}"  # remove openrepos user name
                file="$packages/${source}.rpm"
                local local_file="$update_local_sources/$source.rpm"

                if [[ ! -f "$local_file" ]]; then
                    echo "error: local package file '$local_file' not found" >&2
                    return 1
                else
                    cp --backup=t "$local_file" "$file"
                fi
            elif [[ "$source" == *":"* ]]; then
                # assume openrepos
                local user="${source%%:*}"
                local source="${source#*:}"
                file="$packages/${source}.rpm"

                if [[ -z "$user" ]]; then
                    echo "error: failed to determine OpenRepos user for '$source'" >&2
                    return 1
                fi

                local repo_url="${openrepos_url%/}/${user}/personal/main/${source:0:1}/"
                local html=

                printf -- "%s\n" "fetching $repo_url ..." >&2
                local repo_status="$(curl -LI "$repo_url" 2>/dev/null | head -n 1 | cut -d$' ' -f2)"

                if [[ "$repo_status" != 2[0-9][0-9] ]]; then
                    echo "error: failed to download user \"$user\"'s OpenRepos repository for '$source' (code $repo_status)" >&2
                    echo "       attempted to load: $repo_url" >&2
                    return 1
                else
                    html="$(curl "$repo_url")"
                fi

                set -o pipefail
                local repo; repo="$(hxnormalize -x -e <<<"$html" | hxselect html body a -s "\n" |\
                    sed -E 's/^<a href=".*?\.rpm">//g;s#</a>##g' |\
                    grep "armv7hl" |\
                    sort --version-sort -u)"

                if (( $? != 0 )); then
                    echo "error: failed to extract OpenRepos repository listing for '$source'" >&2
                    return 1
                fi

                local rpms=()
                local versions=()
                readarray -t rpms <<<"$(grep -ie "^$source-[0-9]" <<<"$repo")"
                readarray -t versions <<<"$(grep -ie "^$source-[0-9]" <<<"$repo" | sed "s/^$source-//Ig" | sed 's/.armv7hl.rpm$//g')"

                local last_selected=
                local rpm_count=0
                for pack in "${rpms[@]}"; do
                    if __update_is_valid_version "$version_action" "${versions[$rpm_count]}" "$version"; then
                        last_selected="$pack"
                    fi
                    ((rpm_count++))
                done

                if [[ -z "$last_selected" ]]; then
                    printf -- "%s\n" "error: no package matched '$source' in $repo_url" >&2
                    cd "$base"
                    return 1
                fi

                local last_name="$(grep -ioe "^$source-[0-9]" <<<"$last_selected")"
                last_name="${last_name%-*}"

                if [[ "$last_name" != "$source" ]]; then
                    printf -- "%s\n" "warning: matched package name '$last_name' differs in case from '$source'" >&2
                    printf -- "%s\n" "         check if the downloaded package is correct and update your config file accordingly" >&2
                fi

                cd "$packages"
                local package_url="${repo_url%/}/$last_selected"
                printf -- "%s\n" "fetching package $package_url" >&2

                if ! curl "$package_url" -o "${source}.rpm"; then
                    echo "error: failed to download package '$source'" >&2
                    cd "$base"
                    return 1
                fi
                cd "$base"
            else
                # assume Jolla store
                if [[ -z "$SF_PATCH_SSH_TARGET" ]]; then
                    echo "error: ssh target not set" >&2
                    echo "       cannot fetch packages from official repos without ssh access to the device" >&2
                    return 1
                fi

                echo "downloading package via external device..."
                remote_temp_dir="/tmp/sailfish-patch.tmp"
                ssh "$SF_PATCH_SSH_TARGET" -o ConnectTimeout=3\
                    "rm -rf '$remote_temp_dir'; mkdir -p '$remote_temp_dir' && pkcon download '$remote_temp_dir' '$source'"

                if (( $? != 0 )); then
                    echo "error: failed to download package '$source' from official repos via ssh" >&2
                    return 1
                fi

                scp "$SF_PATCH_REMOTE_USERNAME@$SF_PATCH_SSH_TARGET:$remote_temp_dir/${source}*" "$file"

                if (( $? != 0 )); then
                    echo "error: failed to transfer downloaded package '$source' from the device" >&2
                    return 1
                fi
            fi

            if [[ -n "$version" && -n "$version_action" ]]; then
                if ! __update_is_valid_version "$version_action" "$(rpm -qp --queryformat '%{VERSION}' "$file" 2>/dev/null)" "$version"; then
                    echo "error: could not fetch appropriate version of '$source' ($version$version_action$(rpm -qp --queryformat '%{VERSION}' "$file"))" >&2
                    return 1
                fi
            fi

            cd "$extract"

            if ! rpm2cpio "$file" | cpio -idmv; then
                echo "error: failed to extract '$file'" >&2
                cd "$base"
                return 1
            fi

            updated+=("$file")
            cd "$base"
        done

        cd "$extract"

        prefix="$(get_single_config "$config" "Prefix" "/")"

        if [[ ! -d ".$prefix" ]]; then
            echo "error: invalid prefix $prefix" >&2
            cd "$base"
            return 1
        fi

        cd ".$prefix"
        shopt -s nullglob dotglob
        mkdir -p "$original"
        mv -t "$original" -- * || return 1
        shopt -u nullglob dotglob

        cd "$base"

        printf "\nupdated:\n"
        update_list="$packages/updated"  # TODO documentation
        rm -rf "$update_list"
        for package in "${updated[@]}"; do
            rpm -qp "$package" --qf "- %{NAME}: %{VERSION} (release %{RELEASE}, %{ARCH})\n" | tee -a "$update_list"
        done
        echo

        return 0
    }

    __update_copy_sources() {
        local original="$(__get_original_path)"
        local patched="$(__get_patched_path)"

        if ! rm -rf "$patched"; then
            echo "error: failed to remove old patched sources" >&2
            return 1
        fi

        if [[ ! -d "$original" ]]; then
            echo "error: failed to copy sources - files not found" >&2
            return 1
        fi

        cp -r "$original" "$patched" || return 1
        return 0
    }

    # we assume config has been checked before and is valid
    __update_apply_diff() { # 1: diff file
        local original="$(__get_original_path)"
        local patched="$(__get_patched_path)"
        local relative_patched="$(realpath -m "$patched" --relative-to .)"
        local prefix="$(get_single_config "$(__get_config_path)" "Prefix" "/")"

        local tmp_diff="diff_applying.patch"  # NOTE must be the same same as $working_diff in the updater!
        local patch_command_file="diff_apply_command.sh"  # NOTE must be the same as $patch_command_file in the updater!

        local original_backup="$original.tmp"
        local patched_backup="$patched.tmp"

        { cp -r "$original" "$original_backup" && cp -r "$patched" "$patched_backup"; } || {
            echo "fatal: failed to create temporary copy of pre-patched files" >&2
            echo "error: manual cleanup required" >&2
            return 1
        }

        cp "$1" "$tmp_diff" || {
            printf -- "%s\n" "fatal: failed to copy patch file from '$1' to '$tmp_diff'" >&2
            return 1
        }

        shopt -s extglob
        prefix="$prefix/"            # ensure trailing slash exists
        prefix="${prefix//+(\/)//}"  # remove duplicate slashes
        strip="$(grep -oe '/' <<< "$prefix" | wc -l)"  # count slashes
        shopt -u extglob

        local failed=false
        if [[ "$patch_utility" == "git" ]]; then
            if ! git apply --directory="$relative_patched" --reject --binary -p "$strip" -v "$tmp_diff"; then
                echo "error: failed to apply diff" >&2
                echo -n "patch command: "
                printf -- "%s\n" "git apply --directory='$relative_patched' --reject --binary -p '$strip' -v '$tmp_diff'" | tee "$patch_command_file"
                failed=true
            fi
        elif [[ "$patch_utility" == "patch" ]]; then
            if ! patch -d "$relative_patched" -p"$strip" -u <"$tmp_diff"; then
                echo "error: failed to apply diff" >&2
                echo -n "patch command: "
                printf -- "%s\n" "patch -d '$relative_patched' -p'$strip' -u <'$tmp_diff'" | tee "$patch_command_file"
                failed=true
            fi
        else
            echo "internal error: unknown patch utility '$patch_utility'" >&2
            failed=true
        fi

        if [[ "$failed" == true ]]; then
            rm -rf "$original" "$patched"
            mv "$original_backup" "$original"
            mv "$patched_backup" "$patched"

            cat <<EOF > "$patch_command_file"
#!/bin/bash

patch_file="$(pwd)/$tmp_diff"
patched="$relative_patched"
strip="$strip"

if [[ ! -f "\$patch_file" ]]; then
    printf -- "%s\\n" "error: patch file not found at '\$patch_file'" >&2
    exit 1
fi

if [[ ! -d "\$patched" ]]; then
    printf -- "%s\\n" "error: output directory for patched files not found at '\$patched'" >&2
    exit 1
fi

while true; do
    read -n 1 -s -p "Try to apply the patch using 'wiggle' or 'patch'? [w/p/q]> "

    case "\$REPLY" in
        w|w) printf -- "%s\\n\\n" "applying patch using wiggle...\\n" >&2
             printf -- "%s\\n" "usage:" >&2
             printf -- "%s\\n" "- select files using arrow keys and enter" >&2
             printf -- "%s\\n" "- press q to quit" >&2
             printf -- "%s\\n\\n" "- press v to save the current view and open it in \$EDITOR\\n" >&2
             read -n 1 -s -p "press any key to continue..." CONTINUE

             pushd "\$patched"
             wiggle --strip="\$strip" --browse < "\$patch_file"
             ok="\$?"
             popd; echo
             break
        ;;
        p|P) printf -- "%s\\n" "applying patch using patch..." >&2
             patch -d "\$patched" -p"\$strip" -u < "\$patch_file"
             ok="\$?"
             break
        ;;
        g|G) printf -- "%s\\n" "applying patch using 'git'..." >&2
             git apply --directory="\$patched" --reject --binary -p "\$strip" -v "\$patch_file"
             ok="$?"
             break
        ;;
        q|Q) exit 0;;
        *) printf -- "%s\\n" "unrecognized option '\$REPLY'" >&2;;
    esac
done

exit "\$ok"
EOF

            return 1
        fi

        rm -rf "$original" && mv "$original_backup" "$original"
        rm -rf "$patched_backup"
        rm "$tmp_diff"
    }

    if [[ "$import_inspect" == true ]]; then
        enable_package_detection=true
        patched_files=()
        source_packages=()

        if [[ -z "$SF_PATCH_SSH_TARGET" ]]; then
            printf -- "%s\n"   "warning: SSH target not set" >&2
            printf -- "%s\n\n" "         package detection is only possible with a working SSH connection" >&2
            enable_package_detection=false
        fi

        printf -- "%s\n\n" "Analysing $import_inspect_file..." >&2

        mapfile -d $'\0' -t patched_files < <(grep '^---' unified_diff.patch | \
            cut -f 1 | cut -d ' ' -f 2- | sed -Ee 's@^(a|b|orig[^/]*|jolla)/@/@' | tr '\n' '\0')

        if (( ${#patched_files[@]} == 0 )); then
            printf -- "%s\n" "Detected no patched file." >&2
        elif (( ${#patched_files[@]} == 1 )); then
            printf -- "%s\n" "Detected ${#patched_files[@]} patched file:" >&2
            printf -- "%s\n" "${patched_files[@]}"  # stdout
        else
            printf -- "%s\n" "Detected ${#patched_files[@]} patched files:" >&2
            printf -- "%s\n" "${patched_files[@]}"  # stdout
        fi

        if [[ "$enable_package_detection" == true ]] && (( ${#patched_files[@]} > 0 )); then
            printf -- "%s\n" "" >&2
            echo "=============================="  # stdout
            printf -- "\n%s\n\n" "Searching source packages..." >&2

            escaped_files=()
            for i in "${patched_files[@]}"; do
                escaped_files+=("$(printf -- "%q" "$i")")
            done

            mapfile -t source_packages < <(
                { set -o pipefail; ssh -o ConnectTimeout=3 "$SF_PATCH_SSH_TARGET" \
                        rpm -qf --queryformat "$(printf -- %q '%{NAME} === %{VERSION}\n')" -- "${escaped_files[@]}" | \
                        sort -u | sed -Ee 's/ === (.*?)(\+.*)?/ >= \1/g'; } || {
                    printf -- "%s\n" "error: failed to determine source packages" >&2
                }
            )

            if (( ${#source_packages[@]} == 0 )); then
                printf -- "%s\n" "Detected no source packages." >&2
            elif (( ${#source_packages[@]} == 1 )); then
                printf -- "%s\n" "Detected ${#source_packages[@]} source package:" >&2
                printf -- "%s\n" "${source_packages[@]}"  # stdout
            else
                printf -- "%s\n" "Detected ${#source_packages[@]} source packages:" >&2
                printf -- "%s\n" "${source_packages[@]}"  # stdout
            fi
        else
            printf -- "%s\n" "note: automatic package detection requires a SSH connection" >&2
        fi

        if (( "${#source_packages[@]}" == 0 )) && (( "${#patched_files[@]}" > 0 )); then
            printf -- "\n%s\n" "You can manually determine source packages by running this" >&2
            printf -- "%s\n"   "on the device:  rpm --qf '%{NAME} >= %{VERSION}' -qf FILENAME..." >&2
        fi
    fi

    if [[ "$import" == true ]]; then
        require_outside_repo || exit 1

        require_config "$import_config" || exit 1
        package="$(get_single_config "$import_config" "PackageName")"

        if [[ -e "$package" ]]; then
            printf -- "%s\n" "error: a file or directory with the name '$package' already exists" >&2
            exit 1
        else
            mkdir "$package" || {
                printf -- "%s\n" "error: failed to prepare patch directory '$package'" >&2
                exit 1
            }
        fi

        pre_base="$(pwd)"
        cd "$package"
        cp "$import_config" "$(__get_config_path)"

        # extract tarball
        base="$(pwd)"
        extract_dir=""

        if [[ "$(file --mime-type -b "$import_source")" == "text/x-diff" ]]; then
            # it is a patch file so we can use it directly
            cp "$import_source" "$base/unified_diff.patch"
        elif tar -tf "$import_source" "unified_diff.patch" >/dev/null 2>&1; then
            # it is a tar file, so we extract the patch from it
            tar -xzvf "$import_source" "unified_diff.patch" >/dev/null || {
                printf -- "%s\n" "error: failed to extract patch from tarball" >&2
                printf -- "%s\n" "       You can safely remove '$package' for cleanup." >&2
                cd "$pre_base"
                exit 1
            }
            import_source="$base/unified_diff.patch"
        else
            echo "error: unrecognized source file" >&2
            echo "       Any patch file, or a patch named 'unified_diff.patch' in the" >&2
            echo "       root of a tar archive are supported." >&2
            printf -- "%s\n" "       You can safely remove '$package' for cleanup." >&2
            cd "$pre_base"
            exit 1
        fi

        cd "$base"
        "$import_command" --update "$update_local_sources" || {
            printf -- "\n%s\n\n" "error: failed to import the patch, see above for details" >&2
            printf -- "%s\n"     "       You can either safely remove '$package' for cleanup, or" >&2
            printf -- "%s\n"     "       try to fix the patch and re-run the 'diff_apply_command.sh' helper." >&2
            printf -- "%s\n"     "       If it fails again, checkout the updated sources and try again." >&2
            printf -- "%s\n"     "       If it works, commit the patched files, and delete the remaining workbench files." >&2
            cd "$pre_base"
            exit 1
        }
    fi

    if [[ "$update" == true ]]; then
        require_config "$(__get_config_path)" || exit 1

        original="$(__get_original_path)"
        patched="$(__get_patched_path)"

        readarray -t sources <<<"$(get_multi_config "$(__get_config_path)" "SourcePackages" "")"

        needs_sources=true
        if (( ${#sources[@]} == 1 )) && [[ -z "$(trim "${sources[0]}")" ]]; then
            if [[ -d "$original" && -n "$(shopt -s nullglob; shopt -s dotglob; echo "$original"/* )" ]]; then
                echo "error: no source packages specified but original source files found" >&2
                echo "error: automatic update not possible" >&2
                exit 1
            else
                echo "note: no source packages specified" >&2
                needs_sources=false
                mkdir -p "$original"
            fi
        fi

        if true; then
            # options: user wants to...
            # 1. bootstrap a distributed patch
            #       - unified_diff.patch exists
            #       - all source dirs are missing
            # 2. update sources of an existing patch
            #       - all source dirs exist
            # 3. bootstrap a newly created patch from its configuration
            #       - all source dirs are missing
            #       - unified_diff.patch is missing

            # delete source dirs if they are empty
            rmdir --ignore-fail-on-non-empty "$original"
            rmdir --ignore-fail-on-non-empty "$patched"

            type=update
            latest_commit="$(git rev-parse --verify --short HEAD 2>/dev/null || echo -n "no-git")"
            diff_file="diff_original_${latest_commit}.patch"
            updated_diff="diff_updated_${latest_commit}.patch"
            working_diff="diff_applying.patch"  # NOTE must be the same same as $tmp_diff in __update_apply_diff!
            patch_command_file="diff_apply_command.sh"  # NOTE must be the same as $patch_command_file in __update_apply_diff!

            if [[ ! -d "$original" && ! -d "$patched" && ! -f "$working_diff" ]]; then
                if [[ -f "unified_diff.patch" ]]; then
                    echo "note: bootstrapping distribution package" >&2
                    diff_file="unified_diff.patch"
                    type=dist_bootstrap
                else
                    echo "note: bootstrapping an empty package" >&2
                    type=initial_bootstrap
                fi
            elif [[ ! -d "$original" ]]; then
                echo "error: original files missing" >&2
                exit 1
            elif [[ ! -d "$patched" ]]; then
                echo "error: patched files missing" >&2
                exit 1
            elif [[ -f "$working_diff" ]]; then
                type=retry
                echo >&2
                echo "note: automatic updating failed before, manual steps are required" >&2
                echo >&2
                echo "      Make sure both source directories contain the same updated but unchanged sources." >&2
                echo "      Continue by comitting these updated files into Git, do not reset them" >&2
                echo "      if you want to continue." >&2
                echo >&2
                echo "      Then try to fix the patch in '$working_diff' and re-run the patch command:" >&2
                echo "      $ bash $(realpath -m "$patch_command_file" --relative-to .)" >&2
                echo >&2
                echo "      If it fails again, checkout the updated sources and try again." >&2
                echo "      If it works, commit the patched files, and delete the workbench files" >&2
                echo "      '$working_diff' and '$patch_command_file'." >&2
                exit 0
            fi

            # make sure all source directories exist
            mkdir -p "$original" "$patched" "$(__get_build_path)"

            case "$type" in
                dist_bootstrap|initial_bootstrap)
                    __setup_git_repo || true

                    git add "$(__get_config_path)"
                    [[ "$type" == dist_bootstrap ]] && git add "unified_diff.patch"
                    git commit -m "patch configuration imported by sailfish-patch"

                    latest_commit="$(git rev-parse --verify --short HEAD 2>/dev/null)" || exit 1

                    if [[ "$needs_sources" == true ]]; then
                        printf -- "%s\n" "fetching sources... $latest_commit" >&2
                        { __update_fetch_latest_sources "$latest_commit" && __update_copy_sources; } || {
                            echo "unrolling changes..."
                            rm -rf "$original" "$patched"
                            exit 1
                        }
                    fi

                    git add "$(__get_config_path)" "$original" "$patched"
                    git commit -m "unchanged sources imported by sailfish-patch"

                    if [[ "$type" == dist_bootstrap ]]; then
                        if ! __update_apply_diff "$diff_file"; then
                            echo "error: failed to apply patch to downloaded sources" >&2
                            echo "       Both source directories now contain fresh but unchanged sources." >&2
                            echo "       The original patch is still available in '$diff_file' and you can" >&2
                            echo "       try applying it manually to the files in '$patched'." >&2
                            exit 1
                        else
                            __create_diff "$(__get_config_path)" "$updated_diff"
                            if diff <(sed '/^index/d' "$diff_file") <(sed '/^index/d' "$updated_diff") >/dev/null; then
                                # everything worked perfectly
                                rm "$updated_diff"
                                git rm "unified_diff.patch"
                            else
                                echo "warning: source patch differs from newly generated patch"
                            fi
                        fi
                    fi

                    git add "$(__get_config_path)" "$original" "$patched"
                    git commit -m "patch automatically imported by sailfish-patch"

                    __print_initial_help "$(__get_original_path)" "$(__get_patched_path)" "$(__get_extra_path)"
                ;;
                update)
                    require_inside_repo || exit 1

                    # We only allow changed or untracked files that are not in the original/ or patched/ directories.
                    if [[ -n "$(git status --porcelain=v1 -z | sed -zEe '/^.. (original|patched)\//!d; /^\?\? /d' | tr '\0' '.')" ]]; then
                        tmp_msg="uncommitted source changes found, check original/ and patched/"
                        [[ "$force" == true ]] && echo "warning: $tmp_msg" || { echo "error: $tmp_msg" >&2; exit 1; }
                    fi

                    if [[ -n "$(git status --porcelain=v1 -z | sed -zEe '/^\?\? (original|patched)\//!d' | tr '\0' '.')" ]]; then
                        tmp_msg="untracked source files found, check original/ and patched/"
                        [[ "$force" == true ]] && echo "warning: $tmp_msg" || { echo "error: $tmp_msg" >&2; exit 1; }
                    fi

                    diff_file_temp="$(mktemp -p . "$diff_file.XXXXXX")"
                    mv --backup=t -T "$diff_file_temp" "$diff_file"  # make sure we don't overwrite anything
                    __create_diff "$(__get_config_path)" "$diff_file"

                    original_backup="$original-old-${latest_commit}"
                    mv --backup=t -T "$original" "$original_backup"
                    mkdir -p "$original"

                    if [[ "$needs_sources" == true ]]; then
                        __update_fetch_latest_sources "$latest_commit" || {
                            echo "note: unrolling changes..."
                            rm -rf "$original" && mv -T "$original_backup" "$original"
                            exit 1
                        }
                    fi

                    patched_backup="$patched-old-${latest_commit}"
                    mv --backup=t -T "$patched" "$patched_backup"
                    mkdir -p "$patched"

                    if [[ "$needs_sources" == true ]]; then
                        __update_copy_sources || {
                            echo "note: unrolling changes..."
                            rm -rf "$patched" && mv -T "$patched_backup" "$patched"
                            exit 1
                        }
                    fi

                    { __update_apply_diff "$diff_file" && rm -f "$working_diff"; } || {
                        echo >&2
                        echo "note: the patch must be adapted manually" >&2
                        echo >&2
                        echo "      Both source directories now contain the same updated but unchanged sources." >&2
                        echo "      Continue by comitting these updated files into Git, do not reset them" >&2
                        echo "      if you want to continue." >&2
                        echo >&2
                        echo "      Then try to fix the patch in '$working_diff' and re-run the patch command:" >&2
                        echo "      $ bash $(realpath -m "$patch_command_file" --relative-to .)" >&2
                        echo >&2
                        echo "      If it fails again, you can checkout the updated sources and try again." >&2
                        echo "      The original patch has been saved to '$diff_file'." >&2
                        exit 1
                    }

                    diff_file_temp="$(mktemp -p . "$updated_diff.XXXXXX")"
                    mv --backup=t -T "$diff_file_temp" "$updated_diff"  # make sure we don't overwrite anything
                    __create_diff "$(__get_config_path)" "$updated_diff"

                    if diff <(sed '/^index/d' "$diff_file") <(sed '/^index/d' "$updated_diff") >/dev/null; then
                        echo "success: old and new patch files are identical"
                        echo "         you can remove the backup copies now"
                    else
                        echo "warning: updated patch file has changed" >&2
                    fi
                ;;
                *) echo "error: invalid update type '$type'" >&2 && exit 1;;
            esac
        fi
    fi

    if [[ "$optimize_screenshots" == true ]]; then
        __show_stats() { # 1: title, 2: osize, 3: nsize
            local osize="$2"
            local nsize="$3"
            local change="$((nsize-osize))"
            local state=""

            if ((change > 0)); then
                state="+$(echo "$change" | numfmt --to=iec)"
            elif ((change == 0)); then
                state="no change"
            else
                state="$(echo "$change" | numfmt --to=iec)"
            fi

            echo "$1: $(echo "$osize" | numfmt --to=iec) => $(echo "$nsize" | numfmt --to=iec) ($state)"
        }

        require_config "$(__get_config_path)" || exit 1
        readarray -t screenshots <<<"$(get_multi_config "$(__get_config_path)" "Screenshots")"

        if [[ -z "$optimize_screenshots_runs" ]]; then
            optimize_screenshots_runs=1
        else
            screen_add=" ($optimize_screenshots_runs rounds)"
        fi

        echo "optimizing screenshots$screen_add..."

        screen_files=()
        old_size=0
        for s in "${screenshots[@]}"; do
            screen="$s"
            [[ ! -f "$s" ]] && screen="$(dirname "$config")/$s"
            screen_files+=("$screen")
            old_size=$(( old_size + $(du -bs "$screen" | grep -Poe '^\d+') ))
        done

        last_size=$old_size
        for i in $(seq 1 "$optimize_screenshots_runs"); do
            (( $optimize_screenshots_runs > 1 )) && echo "round $i / $optimize_screenshots_runs..."
            new_size=0
            for s in "${screen_files[@]}"; do
                convert -resize 1200x1200\> "$s" "$s-resized.png"
                pngcrush "$s-resized.png" "$s-crushed.png" && pngquant "$s-crushed.png"
                mv "$s-crushed-fs8.png" "$s"
                rm "$s-resized.png" "$s-crushed.png"
                new_size=$(( new_size + $(du -bs "$s" | grep -Poe '^\d+') ))
            done

            (( $optimize_screenshots_runs > 1 )) && __show_stats "round $i" "$last_size" "$new_size"
            last_size="$new_size"
            unset screen
        done

        new_size=0
        for s in "${screen_files[@]}"; do
            new_size=$(( new_size + $(du -bs "$s" | grep -Poe '^\d+') ))
        done

        __show_stats "screenshots optimized" "$old_size" "$new_size"
    fi

    if [[ "$build" == true ]]; then
        # require valid config and build directory
        require_build_config || exit 1
        base="$(pwd)"
        config="$(__get_config_path)"
        build_dir="$(__get_build_path)"
        extra_dir="$(__get_extra_path)"
        original="$(__get_original_path)"
        patched="$(__get_patched_path)"
        package_extra_files=true

        # require original files
        if [[ ! -d "$original" ]]; then
            echo "note: creating empty original files directory" >&2
            mkdir -p "$original" || {
                echo "error: failed to create empty original files directory" >&2
                echo "       Even if the patch only adds files, the 'original'" >&2
                echo "       directory has to be present." >&2
                exit 1
            }
        fi

        if [[ ! -d "$patched" && ! -d "$extra_dir" ]]; then
            # patches may only add a settings page, so the patched directory is only
            # a hard requirement when no extra files are added
            echo "error: missing patched files directory" >&2
            exit 1
        else
            mkdir -p "$patched" || {
                echo "error: failed to create empty patched files directory" >&2
                exit 1
            }
        fi

        # verify extra files (imported later, so we don't have to clean up if something fails)
        if [[ -d "$extra_dir" ]]; then
            if (( $(find "$extra_dir" -mindepth 1 -type d | wc -l) > 0 )); then
                echo "error: subdirectories are not allowed for extra files" >&2
                exit 1
            fi

            all_extra_files="$(find "$extra_dir" -type f -print0 | tr -d '\n' | tr '\0' '\n')"
            if grep -Pqve "\.(qml|js|png|svg|qm)$" <<<"$all_extra_files"; then
                echo "error: unsupported extra files found" >&2
                echo "       Only files with the following extensions are allowed:" >&2
                echo "          .qml, .js, .png, .svg, .qm" >&2
                exit 1
            fi

            langs="$(find "$extra_dir" -type f -iname "*.qm" -execdir printf "%s\0" {} \; | tr '\n' '%' | tr '\0' '\n')"
            if [[ -n "$langs" ]] && echo "$langs" | grep -Pqve "^./translation_[a-zA-Z_]{2,5}.qm$"; then
                echo "error: invalid translation file names found" >&2
                echo "       Translation files must follow the format 'translation_LANG.qm'," >&2
                echo "       e.g. 'translation_en.qm' or 'translation_zh_TW.qm'" >&2
                exit 1
            fi

            qmls="$(find "$extra_dir" -type f -iname "*.qml" -print0 | tr '\n' '\t' | tr '\0' '\n')"
            if [[ -n "$qmls" ]]; then
                if (( $(wc -l <<<"$all_extra_files") == 1 )) &&
                       (( $(wc -l <<<"$qmls") == 1 )) &&
                       grep -Pqe "/$cDEFAULT_QMLDETAILS_NAME" <<<"$qmls"; then
                    # there are no user-provided extra files, only the generated details page
                    package_extra_files=false
                elif ! echo "$qmls" | grep -Pqe '/main.qml$'; then
                    echo "error: extra QML files found but no main file" >&2
                    echo "       A file named 'main.qml' must be provided" >&2
                    echo "       when including extra QML files." >&2
                    echo "" >&2
                    echo "       Rename/remove the '$extra_dir' directory," >&2
                    echo "       or add a 'main.qml' file to continue." >&2
                    exit 1
                fi
            fi
        fi

        # create temp dir
        temp_build_dir="$(mktemp -d -p "$build_dir" build.XXXX)"

        # generate details QML file if needed
        rmdir "$extra_dir" --ignore-fail-on-non-empty

        if [[ -d "$extra_dir" && -f "$extra_dir/main.qml" && ! -f "$extra_dir/$cDEFAULT_QMLDETAILS_NAME" ]]; then
            printf -- "%s\n" "note: creating $extra_dir/$cDEFAULT_QMLDETAILS_NAME to be used on settings pages" >&2
            __save_template_qmldetails "$extra_dir/$cDEFAULT_QMLDETAILS_NAME"
            sed -i "s/@PACKAGENAME@/$(get_single_config "$config" "PackageName")/g" "$extra_dir/$cDEFAULT_QMLDETAILS_NAME"
        fi

        # import extra files
        if [[ "$package_extra_files" == true ]]; then
            if [[ -d "$extra_dir" ]] && ! rmdir "$extra_dir" 2>/dev/null; then
                if (( $(find "$extra_dir" -type f -iregex ".*\.\(qml\|js\|png\|svg\|qm\)$" | wc -l) > 0 )); then
                    mkdir -p "$temp_build_dir/extra"
                    find "$extra_dir" -type f -iregex ".*\.\(qml\|js\|png\|svg\|qm\)$" -exec cp {} "$temp_build_dir/extra" \;
                else
                    printf -- "%s\n" "warning: directory for extra files found but there are no usable files" >&2
                    printf -- "%s\n" "         allowed file types are: qml, js, png, svg, qm" >&2
                fi
            fi
        fi

        # create diff
        __create_diff "$config" "${temp_build_dir}/unified_diff.patch"

        cd "$temp_build_dir" # important: switch to temp_build_dir

        # prepare files and templates
        rpm_build_dir="$temp_build_dir/rpm_build"
        tarball_build_dir="$temp_build_dir/tarball_build"
        dist_build_dir="$temp_build_dir/dist_build"

        mkdir -p "$rpm_build_dir" "$tarball_build_dir" "$dist_build_dir"

        __save_template_spec "$rpm_build_dir/$cDEFAULT_SPEC_NAME"
        __save_template_json "$rpm_build_dir/$cDEFAULT_JSON_NAME"

        if [[ -d extra && -n "$(shopt -s nullglob; shopt -s dotglob; echo extra/* )" ]]; then
            cp extra/* "$rpm_build_dir"
            mkdir -p "$dist_build_dir/extra" && cp extra/* "$dist_build_dir/extra"
            mv extra/* "$tarball_build_dir"
        fi

        cp unified_diff.patch "$rpm_build_dir/unified_diff.patch"
        cp unified_diff.patch "$dist_build_dir/unified_diff.patch"
        mv unified_diff.patch "$tarball_build_dir/unified_diff.patch"

        if [[ -f "$base/$cDEFAULT_LICENSE_NAME" ]]; then
            cp "$base/$cDEFAULT_LICENSE_NAME" "$dist_build_dir"
        fi

        cp "$config" "$dist_build_dir"
        readarray -t screenshots <<<"$(get_multi_config "$config" "Screenshots")"

        for s in "${screenshots[@]}"; do
            if [[ -f "$s" || -f "$(dirname "$config")/$s" ]]; then
                [[ -f "$s" ]] && cp "$s" "$dist_build_dir" || cp "$(dirname "$config")/$s" "$dist_build_dir"
                s="${s//\//\\/}" # escape slashes
                sed -E -i "s/-[ \t]*$s$/- $(basename "$s")/g" "$dist_build_dir/$(basename "$config")"
            fi
        done

        rpm_version="$(get_single_config "$config" "Version")"
        release="$(get_single_config "$config" "Release")"
        package="$(get_single_config "$config" "PackageName")"
        echo "building version: $rpm_version-$release"

        # configure spec, json, and qml files
        for i in PackageName Summary Version Release License Maintainer DisplayName Category DiscussionLink DonationsLink SourcesLink; do
            value="$(get_single_config "$config" "$i")"
            [[ -z "$value" ]] && value="" # empty values will be left empty

            value="${value//\//\\/}" # escape slashes
            sed -i "s/@${i^^}@/$value/g" "$rpm_build_dir/$cDEFAULT_SPEC_NAME"
            sed -i "s/@${i^^}@/$value/g" "$rpm_build_dir/$cDEFAULT_JSON_NAME"

            if [[ -f "$rpm_build_dir/$cDEFAULT_QMLDETAILS_NAME" ]]; then
                sed -i "s/@${i^^}@/$value/g" "$rpm_build_dir/$cDEFAULT_QMLDETAILS_NAME"
                sed -i "s/@${i^^}@/$value/g" "$tarball_build_dir/$cDEFAULT_QMLDETAILS_NAME"
            fi
        done

        # configure json-specific fields
        description="$(get_multi_config "$config" "Description")"
        description="${description//\"/\\\\\"}" # escape quotes
        description="${description//&/\\\\&}" # escape ampersand
        awk -v r="$description" '{gsub(/@DESCRIPTION@/,r)}1'\
            "$rpm_build_dir/$cDEFAULT_JSON_NAME" > _tmp && mv _tmp "$rpm_build_dir/$cDEFAULT_JSON_NAME"

        readarray -t compatible_versions <<<"$(get_multi_config "$config" "CompatibleVersions")"
        compatible_versions="$(printf -- '"%s", ' "${compatible_versions[@]}" | sed -Ee 's/, $//g' | sed -Ee 's/^""//g')"
        awk -v r="$compatible_versions" '{gsub(/@COMPATIBLEVERSIONS_LIST@/,r)}1'\
            "$rpm_build_dir/$cDEFAULT_JSON_NAME" > _tmp && mv _tmp "$rpm_build_dir/$cDEFAULT_JSON_NAME"

        # configure rpm-specific fields
        # NOTE: we don't deduplicate any entries, neither do we check for invalid
        # or contradictory lines. If it's a problem, rpmbuild can find it.
        description="$(get_multi_config "$config" "Description")"
        description="${description//%/%%}" # escape percent
        description="$(trim "$description")"
        description="${description:-%\{summary\}}"  # fallback to summary as placeholder
        awk -v r="$description" '{gsub(/@DESCRIPTION@/,r)}1'\
            "$rpm_build_dir/$cDEFAULT_SPEC_NAME" > _tmp && mv _tmp "$rpm_build_dir/$cDEFAULT_SPEC_NAME"

        changelog="$(get_multi_config "$config" "Changelog" |\
            LC_ALL=C awk -v today="$(LC_ALL=C date "+%a %b %d %Y")" \
                         -v maintainer="$(get_single_config "$config" "Maintainer")" 'BEGIN {
                # This script rewrites version lines to proper RPM changelog header lines.
                # It converts these formats:
                #       x.y.z (2023-01-01):
                #       x.y.z-r (2023-01-01):
                #       x.y.z-r:
                #       x.y.z:
                # To this format:
                #       * Sun Apr 16 2023 maintainer <> - x.y.z-r
                # Today´s date is used if no date was specified.
                #
                # All other lines are kept as-is.

                version_re="^([0-9]+\\.[0-9]+\\.[0-9]+)(-([0-9]+))?(\\s\\(([0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9])\\))?:"
            } {
                # is it a version line?
                if ($0 ~ version_re) {
                    match($0, version_re, m);

                    # does it have a date?
                    if (m[5]) {
                        # convert dates
                        cmd="date -d " m[5] " \"+%a %b %d %Y\" ";
                        cmd | getline converted;
                        close(cmd);
                    } else {
                        converted=today;
                    }

                    # does it have a release number?
                    if (m[3]) {
                        release=m[3]
                    } else {
                        release="1"
                    }

                    # format as RPM version line, following:
                    # https://rpm-packaging-guide.github.io/#working-with-spec-files (section 5)
                    print "* " converted " " maintainer " - " m[1] "-" release;
                } else {
                    print;
                }
            }'
        )"
        awk -v r="$changelog" '{gsub(/@CHANGELOG@/,r)}1'\
            "$rpm_build_dir/$cDEFAULT_SPEC_NAME" > _tmp && mv _tmp "$rpm_build_dir/$cDEFAULT_SPEC_NAME"

        for i in Requires Obsoletes Conflicts; do
            values="$(get_multi_config "$config" "$i")"

            if [[ -n "$values" ]]; then
                readarray -t m_lines <<<"$(echo "$values")"
                m_clean_lines=()

                for l in "${m_lines[@]}"; do
                    [[ -z "$l" ]] && continue
                    l="${l//\//\\/}" # escape slashes

                    # special case: package requires all packages listed in
                    # SourcePackages. Field references are otherwise not supported.
                    if [[ "$i" == Requires && "$l" == "@sources" ]]; then
                        readarray -t rpm_config_requires_sources <<<"$(get_multi_config "$config" "SourcePackages")"

                        for s in "${rpm_config_requires_sources[@]}"; do
                            [[ -z "$s" ]] && continue
                            s="${s//\//\\/}" # escape slashes
                            m_clean_lines+=("${s#*:}")  # remove OpenRepos username
                        done
                    else
                        m_clean_lines+=("$l")
                    fi
                done

                for l in "${m_clean_lines[@]}"; do
                    sed -i "$(echo -en "/@${i^^}@/i\\\\\n$i: $l")" "$rpm_build_dir/$cDEFAULT_SPEC_NAME"
                done

                if [[ "$i" == Obsoletes ]]; then
                    for l in "${m_clean_lines[@]}"; do
                        sed -i "$(echo -en "/@${i^^}@/i\\\\\nProvides: ${l// < / = }")" "$rpm_build_dir/$cDEFAULT_SPEC_NAME"
                    done
                fi
            fi

            sed -i "s/@${i^^}@//g" "$rpm_build_dir/$cDEFAULT_SPEC_NAME"
        done

        # prepare reproducible environment
        SOURCE_DATE_EPOCH="$(git log -1 --pretty=%ct)"
        export SOURCE_DATE_EPOCH

        # build rpm
        echo "building RPM..."

        temp_spec_file="$(mktemp -p "$(pwd)" 'sailfish-patch-rpm_XXXX.spec')"
        mv "$rpm_build_dir/$cDEFAULT_SPEC_NAME" "$temp_spec_file"  # to make sure it's not included in the RPM

        if [[ "$build_inspect" == true ]]; then
            cd "$base"
            printf -- "%s\n" "inspection mode: aborting without building packages" >&2
            printf -- "%s\n" "                 configured build sources can be found in" >&2
            printf -- "%s\n" "                     $temp_build_dir" >&2
            exit 0
        fi

        rpmbuild -bb --build-in-place "$temp_spec_file" --define "_rpmdir $(pwd)/RPMS"

        if (( $? != 0 )); then
            backup_spec="$base/$(basename "$base").spec"
            cp --backup=t "$temp_spec_file" "$backup_spec"

            echo "error: failed to build RPM" >&2
            echo "note: the generated RPM spec file can be inspected here" >&2
            echo "          $backup_spec" >&2
            echo "      Please report invalidly generated spec files as a bug at" >&2
            echo "          https://github.com/ichthyosaurus/sailfish-patch" >&2
            echo "      Include the problematic spec file and all log messages in the report." >&2
        else
            mv --backup=t RPMS/**/*.rpm "$build_dir"
            rm "$temp_spec_file"
            echo "success: RPM built"
        fi

        # build tarball
        echo "building tarball..."
        cd "$tarball_build_dir"
        tarball="$package-$rpm_version-$release.tar.gz"
        TZ=UTC0 LC_ALL=C tar --sort=name --numeric-owner --owner=0 --group=0 \
            --mtime="$(date --utc --date="@${SOURCE_DATE_EPOCH:-$(date +%s)}" +"%Y-%m-%d 00:00:00")" --clamp-mtime \
            --pax-option=exthdr.name=%d/PaxHeaders/%f,delete=atime,delete=ctime \
            -czvf "$tarball" *

        if (( $? != 0 )); then
            echo "error: failed to build tarball" >&2
        else
            echo "success: tarball built"
            mv --backup=t "$tarball" "$build_dir"
        fi

        # build code distribution package
        echo "building code distribution package..."
        mv "$dist_build_dir" "$package" &&\
            mv --backup=t "$package" "$build_dir"

        if (( $? != 0 )); then
            echo "error: failed to build code distribution package" >&2
        else
            echo "success: code distribution package built"
        fi

        # clean up
        rm -r "$temp_build_dir"
        cd "$base"
    fi

    if [[ "$publish_via_ssh" == true ]]; then
        echo "deploying patch..."
        require_current_package rpm || exit 1
        rpm="$(__get_package_path rpm)"
        echo "package: $rpm"

        if [[ ! -f "$SF_PATCH_PASSFILE" ]]; then
            echo "error: passphrase file not found" >&2
            exit 2
        fi

        config="$(__get_config_path)" # we assume it has been checked before
        package_name="$(get_single_config "$config" "PackageName")"

        scp "$rpm" "$SF_PATCH_REMOTE_USERNAME@$SF_PATCH_SSH_TARGET:$SF_PATCH_REMOTE_PATH"
        { { head -1 "$SF_PATCH_PASSFILE" | ssh -o ConnectTimeout=3 "$SF_PATCH_SSH_TARGET" \
                "devel-su rpm -Uvh --replacepkgs --oldpackage '$SF_PATCH_REMOTE_PATH/$(basename "$rpm")'"; } || {
            echo "error: failed to install patch package" >&2 && false
        }; } &&\
        { { head -1 "$SF_PATCH_PASSFILE" | ssh -o ConnectTimeout=3 "$SF_PATCH_SSH_TARGET" "devel-su /usr/sbin/patchmanager -a '$package_name'"; } || {
            echo "error: failed to apply patch" >&2 && false
        }; }

        install_success=$?

        needs_keyboard="$(get_multi_config "$config" "Requires" | paste -s -d'\n' - <(get_multi_config "$config" "SourcePackages") | grep -oe '^jolla-keyboard')"
        if [[ -n "$needs_keyboard" ]]; then
            echo && echo "restarting keyboard service..."
            { ssh -o ConnectTimeout=3 "$SF_PATCH_SSH_TARGET" "systemctl --user restart maliit-server"; } || {
                echo "warning: failed to restart keyboard service (maliit-server)" >&2 && false
            }
        fi

        if (( $install_success > 0 )); then
            echo "failed to deploy patch" >&2
        else
            echo "patch deployed"
        fi

        readarray -t test_commands <<<"$(get_multi_config "$config" "TestCommands")"
        test_commands_clean=()

        for cmd in "${test_commands[@]}"; do
            [[ -n "$cmd" ]] && test_commands_clean+=("$cmd")
        done

        if (( ${#test_commands_clean[@]} > 0 )); then
            printf "\n%s\n" "test commands:"
            printf -- "- %s\n" "${test_commands_clean[@]}"
            echo

            read -n 1 -s -p "run these commands on the device? (y/N)> "
            if [[ "$REPLY" == "y" ]]; then
                echo "executing commands via SSH..."
                ssh -o ConnectTimeout=3 "$SF_PATCH_SSH_TARGET" "$(printf -- " %s ; " "${test_commands_clean[@]}")" || {
                    echo "warning: test commands failed" >&2 && false
                }
            else
                echo "test commands skipped"
            fi
        fi
    fi

    __wizard_load() { # 1: type, 2: title, 3: key
        local config="$(__get_config_path)" # we assume it has been checked before

        if [[ "${1:0:1}" == "s" ]]; then
            local value="$(get_single_config "$config" "$3")"
        else
            local value="$(get_multi_config "$config" "$3")"
        fi

        echo -n "$value" | xclip -selection c

        if [[ "${1:0:1}" == "s" ]]; then
            read -n 1 -s -p "$2: $value"; echo
        else
            read -n 1 -s -p "$2:
$value"
            echo
        fi

    }

    __wizard_load_screenshots() {
        local config="$(__get_config_path)" # we assume it has been checked before
        local first_path="$(get_multi_config "$config" "Screenshots" | head -1)"

        if [[ "${first_path:0:1}" == "/" ]]; then
            local screenshots_path="$(readlink -m "$(dirname "$first_path")")"
        elif [[ -n "$first_path" ]]; then
            # relative paths are relative to the config file
            local screenshots_path="$(readlink -m "$(dirname "$(__get_config_path)")")"
        else
            local screenshots_path=
        fi

        echo -n "$screenshots_path" | xclip -selection c
        read -n 1 -s -p "Screenshots (first directory path): $screenshots_path"; echo
    }

    __wizard_load_changelog() { # 1: target ('openrepos' or 'catalogue')
        local config="$(__get_config_path)" # we assume it has been checked before
        local changelog="$(get_multi_config "$config" "Changelog")"

        if [[ "$1" == "openrepos" ]]; then
            # put each paragraph separated by a blank line into <p> tags,
            # end each line with <br>
            readarray -t changelog_lines <<<"$changelog"
            changelog=

            local in_paragraph=false
            for l in "${changelog_lines[@]}"; do
                l="$(trim "$l")"

                if [[ -n "$l" ]]; then
                    if [[ "$in_paragraph" == false ]]; then
                        in_paragraph=true
                        changelog+="<p>"
                    fi
                    changelog+="$l<br>"
                else
                    if [[ "$in_paragraph" == true ]]; then
                        changelog="${changelog%<br>}</p>
" # newline intended
                    fi
                    in_paragraph=false
                fi
            done
        else
            local most_recent=""
            if most_recent="$(cat <<<"$changelog" | awk \
                    -v expected="$(get_single_config "$config" "Version")" \
                    -v release="$(get_single_config "$config" "Release")" 'BEGIN {
                # This script extracts the changelog section for the current version.
                # It assumes that the changelog is correctly formatted.
                #
                # If the script fails, the wizard will copy the whole changelog.

                have_version=0
                ignore_section=0
                version_re="^([0-9]+\\.[0-9]+\\.[0-9]+)(-([0-9]+))?(\\s\\(([0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9])\\))?:"
            } {
                gsub(/^[ \t]+|[ \t]+$/, "", $0)  # trim

                if ($0 ~ version_re) {
                    if (have_version) {
                        # next section found - quit
                        exit 0;
                    } else {
                        match($0, version_re, m);

                        if (m[1] != expected) {
                            ignore_section=1
                        } else {
                            if (m[3] == release || release == "" || (release == "1" && m[3] == "")) {
                                # mark as beginning but do not actually print the line
                                have_version=1
                                ignore_section=0
                            } else {
                                ignore_section=1
                            }
                        }
                    }
                } else {
                    if ($0 && !have_version && !ignore_section) {
                        # we have not encountered a version line yet but there
                        # appears to be content here - abort
                        exit 1;
                    } else {
                        if (!ignore_section) {
                            print;
                        }
                    }
                }
            }')"; then
                most_recent="$(trim "$most_recent")"

                if [[ -n "$most_recent" ]]; then
                    changelog="$most_recent"
                else
                    printf -- "%s\n" "warning: could not find a matching changelog section for this version" >&2
                fi
            fi
        fi

        echo -n "$changelog" | xclip -selection c

        read -n 1 -s -p "Changelog:
$changelog"  # newline intended
        echo
    }

    __wizard_load_description() { # 1: target ('openrepos' or 'catalogue')
        local config="$(__get_config_path)" # we assume it has been checked before
        local description="$(get_multi_config "$config" "Description")"

        # - put each paragraph separated by a blank line into <p> tags
        readarray -t description_lines <<<"$description"
        description=

        local in_paragraph=false
        for l in "${description_lines[@]}"; do
            l="$(trim "$l")"

            if [[ -n "$l" ]]; then
                if [[ "$in_paragraph" == false ]]; then
                    in_paragraph=true
                    description+="<p>"
                fi
                description+="$l "
            else
                if [[ "$in_paragraph" == true ]]; then
                    description="${description% }</p>
" # newline intended
                fi
                in_paragraph=false
            fi
        done

        # html-ify links and very basic highlighting
        description="$(echo "$description" |\
            perl -p0e 's/\[(.*?)\]\((.+?)\)/<a href="\2">\1<\/a>/g' |\
            perl -p0e 's/\B\*\*(.+?)\*\*\B/<b>\1<\/b>/g; s/\b_?_(.+?)_?_\b/<u>\1<\/u>/g; s/\B\*(.+?)\*\B/<i>\1<\/i>/g')"

        if [[ "$1" == "openrepos" ]]; then
            # append extra links
            local sources_link="$(get_single_config "$config" "SourcesLink")"
            local discussion_link="$(get_single_config "$config" "DiscussionLink")"
            local donations_link="$(get_single_config "$config" "DonationsLink")"

            for l in "Sources:$sources_link" "Discussion:$discussion_link" "Donations:$donations_link"; do
                if [[ -n "${l#*:}" ]]; then
                    description="$description
<p>${l%%:*}: <a href=\"${l#*:}\">${l#*:}</a></p>"
                fi
            done
        elif [[ "$1" == "catalogue" ]]; then
            # Translate html tags (back) to plain text; links are replaced by an in-text representation.
            # This back-and-forth makes sure everything is properly cleaned up.
            description="$(echo "$description" | html2text -b 0 --reference-links --no-wrap-links | perl -p0e 's/\[(.*?)\]\[([0-9]+)\]/\1 (\2)/g')"
        else
            echo "internal error: invalid description target given ('$1')" >&2
        fi

        echo -n "$description" | xclip -selection c

        read -n 1 -s -p "Description:
$description"  # newline intended
        echo
    }

    if [[ "$publish_to_openrepos" == true ]]; then
        echo "running wizard for publishing to OpenRepos..."
        echo "Each value will be copied to the clipboard. Press any key to load the"
        echo "next value."
        echo
        require_current_package rpm || exit 1
        rpm="$(__get_package_path rpm)"
        config="$(__get_config_path)" # safe because we already checked above
        name="$(get_single_config "$config" "DisplayName")"

        if [[ "$publish_update_only" == true ]]; then
            echo "Patch: $name"
        else
            echo -n "Patch: $name" | xclip -selection c
            read -n 1 -s -p "Application name: Patch: $name"; echo

            echo -n "Applications -> Patches" | xclip -selection c
            read -n 1 -s -p "Category: Applications -> Patches"; echo

            readarray -t keywords <<<"$(get_multi_config "$config" "Keywords")"
            for i in "${keywords[@]}"; do
                echo -n "$i" | xclip -selection c
                read -n 1 -s -p "Keyword: $i"; echo
            done

            icon_file="/tmp/$cDEFAULT_ICON_NAME"
            __save_template_icon "$icon_file"
            echo -n "$icon_file" | xclip -selection c
            read -n 1 -s -p "Icon: $icon_file"; echo

            __wizard_load s "Summary" "Summary"
            __wizard_load_description "openrepos"
            __wizard_load_screenshots
        fi

        echo -n "$rpm" | xclip -selection c
        read -n 1 -s -p "Application version: $rpm"; echo

        __wizard_load_changelog openrepos
    fi

    if [[ "$publish_to_pm_catalogue" == true ]]; then
        echo "running wizard for publishing to Patchmanager's online catalogue..."
        echo "Each value will be copied to the clipboard. Press any key to load the"
        echo "next value."
        echo
        require_current_package tarball || exit 1
        config="$(__get_config_path)" # safe because we already checked above
        tarball="$(__get_package_path tarball)"

        if [[ "$publish_update_only" == true ]]; then
            echo "Patch: $(get_single_config "$config" "DisplayName")"
        else
            __wizard_load s "Internal name" "PackageName"
            __wizard_load s "Display name" "DisplayName"
            __wizard_load_description "catalogue"
            __wizard_load s "Category" "Category"
            __wizard_load s "Discussion link" "DiscussionLink"
            __wizard_load s "Donations link" "DonationsLink"
            __wizard_load s "Sources link" "SourcesLink"
            __wizard_load_screenshots
        fi

        __wizard_load s "Version" "Version"
        __wizard_load m "Compatible versions" "CompatibleVersions"
        echo -n "$tarball" | xclip -selection c
        read -n 1 -s -p "Patch archive: $tarball"; echo

        if [[ "$publish_update_only" == true ]]; then
            full_changelog="$(get_multi_config "$config" "Changelog")"
            version="$(get_single_config "$config" "Version")"
            update_changelog="$(echo "$full_changelog" | select_range "^[*]?.*?${version//./\.}.*?:" "^[*]?.*?[0-9]+.*?:")"
            echo -n "$update_changelog" | xclip -selection c

            read -n 1 -s -p "Changelog:
$update_changelog"
            echo
        else
            __wizard_load_changelog catalogue
        fi

        echo "done"
    fi
fi

if (( ${#debug_export_template[@]} > 0 )); then
    # __save_file() { # 1: file name
    #     if [[ -f "$1" ]]; then  # make sure we don't overwrite anything
    #         file_temp="$(mktemp -p . sailfish-patch-XXXX.tmp)"
    #         mv --backup=t -T "$file_temp" "$1" && rm "$1"
    #     fi
    #     echo "$1"
    # }

    for i in "${debug_export_template[@]}"; do
        case "$i" in
            config) __save_template_config /dev/stdout;;        # "$(__save_file "$cDEFAULT_CONFIG_NAME.template")";;
            gitignore) __save_template_gitignore /dev/stdout;;  # "$(__save_file ".$i")";;
            icon) __save_template_icon /dev/stdout;;            # "$(__save_file "$i.png")";;
            json) __save_template_json /dev/stdout;;            # "$(__save_file "$i.json")";;
            spec) __save_template_spec /dev/stdout;;            # "$(__save_file "$i.spec")";;
            qmldetails) __save_template_qmldetails /dev/stdout;; # "$(__save_file "$i.qml")";;
            license)
                config="$(__get_config_path)"
                require_config "$config" || {
                    printf -- "%s\n" "error: cannot save license text" >&2
                    exit 1
                }
                license="$(get_single_config "$config" "License")"
                __save_template_copying "$cDEFAULT_LICENSE_NAME" "$license"
                printf -- "%s\n" "saved license $license to $cDEFAULT_LICENSE_NAME" >&2
            ;;
        esac
    done
fi
